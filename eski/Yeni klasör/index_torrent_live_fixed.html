<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Sinema ULTRA - Optimized</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    
    <!-- A-Frame VR -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    
    <!-- Adaptive Streaming (ABR): HLS.js + dash.js -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.6.15/dist/hls.min.js"></script>
    <script src="https://cdn.dashjs.org/v5.1.1/modern/umd/dash.all.min.js"></script>
    <!-- P2P (WebTorrent) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/webtorrent/0.108.0/webtorrent.min.js"></script>
    <STYLe>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow-x: hidden;
        }
        
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.95);
            transition: opacity 0.3s;
        }
        
        #ui-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .container {
            max-width: 600px;
            width: 90%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 16px;
        }
        
        textarea {
            min-height: 80px;
            resize: vertical;
        }
        
        button {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        #room-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }
        
        .room-item {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .room-item:hover {
            background: rgba(255, 255, 255, 0.25);
        }
        
        .room-name {
            font-weight: 600;
            font-size: 18px;
            margin-bottom: 5px;
        }
        
        .room-details {
            font-size: 14px;
            opacity: 0.8;
        }
        
        #vr-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 500;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            display: none;
            gap: 10px;
            align-items: center;
        }
        
        #vr-controls button {
            width: auto;
            padding: 10px 20px;
            margin: 0 5px;
            font-size: 14px;
        }
        
        #room-info {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 500;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            display: none;
            max-width: 300px;
        }
        
        #sync-status {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 500;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 10px 15px;
            border-radius: 10px;
            display: none;
            font-size: 14px;
        }
        
        #p2p-status {
            position: fixed;
            bottom: 140px;
            right: 20px;
            z-index: 500;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 10px 12px;
            border-radius: 10px;
            display: none;
            font-size: 12px;
            line-height: 1.35;
            min-width: 220px;
        }

        #p2p-progress-container {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.18);
            border-radius: 999px;
            overflow: hidden;
            margin-top: 6px;
        }

        #p2p-progress-bar {
            height: 100%;
            width: 0%;
            background: rgba(74, 222, 128, 0.95);
            transition: width .4s ease-in-out;
        }

        
        .status-good { color: #4ade80; }
        .status-warning { color: #fbbf24; }
        .status-error { color: #f87171; }
        
        #buffer-countdown {
            position: fixed;
            top: 60px;
            right: 20px;
            z-index: 500;
            background: rgba(255, 165, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 8px 12px;
            border-radius: 8px;
            display: none;
            font-size: 13px;
            font-weight: 600;
            color: white;
        }
        
        #viewer-count {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        a-scene {
            width: 100%;
            height: 100vh;
        }
        
        .hidden {
            display: none !important;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }
            h1 {
                font-size: 2em;
            }
            #vr-controls {
                bottom: 10px;
                padding: 10px;
            }
        }
    </STYLe>
    
</head>
<body>
    <!-- UI Overlay -->
    <div id="ui-overlay">
        <div class="container">
            <h1>üé¨ VR Sinema ULTRA</h1>
            
            <div id="create-room-section">
                <div class="input-group">
                    <label>Oda Adƒ±</label>
                    <input type="text" id="room-name" placeholder="√ñzel film gecesi">
                </div>
                
                <div class="input-group">
                    <label>Video URL</label>
                    <input type="text" id="video-url" placeholder="YouTube, Google Drive veya direkt video linki">
                </div>
                
                <div class="input-group">
                    <label>veya Lokal Dosya (P2P)</label>
                    <input type="file" id="video-file" accept="video/*">
                    <div style="margin-top:6px; font-size:12px; opacity:0.85;">
                        Lokal dosya se√ßerseniz URL bo≈ü kalabilir. Dosya P2P (WebTorrent) ile payla≈üƒ±lƒ±r.
                    </div>
                </div>

                
                <div class="input-group">
                    <label>A√ßƒ±klama (isteƒüe baƒülƒ±)</label>
                    <textarea id="room-description" placeholder="Bu odada ne izlenecek?"></textarea>
                </div>
                
                <div class="input-group">
                    <label>Ekran Boyutu</label>
                    <select id="screen-size">
                        <option value="medium">Orta (16:9)</option>
                        <option value="large">B√ºy√ºk (21:9)</option>
                        <option value="imax">IMAX (1.43:1)</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label>Ortam</label>
                    <select id="environment">
                        <option value="none">Yok (En Hƒ±zlƒ±)</option>
                        <option value="minimal">Minimal</option>
                    </select>
                </div>
                
                <button onclick="createRoom()">üöÄ Oda Olu≈ütur ve Katƒ±l</button>
                <button onclick="showRoomList()">üìã Mevcut Odalar</button>
            </div>
            
            <div id="room-list-section" class="hidden">
                <button onclick="showCreateRoom()">‚Üê Geri</button>
                <div id="room-list"></div>
            </div>
        </div>
    </div>
    
    <!-- VR Controls (2D overlay) -->
    <div id="vr-controls">
        <button id="btn-play" onclick="playVideo()">‚ñ∂Ô∏è Oynat</button>
        <button id="btn-pause" onclick="pauseVideo()">‚è∏Ô∏è Duraklat</button>
        <button id="btn-rewind" onclick="seekBackward()">‚è™ -10s</button>
        <button id="btn-forward" onclick="seekForward()">‚è© +10s</button>
        <button id="btn-sync" onclick="initiateSync()">üîÑ Sync</button>
                <button id="btn-quality-down" onclick="decreaseMaxQuality()">üìâ Kalite -</button>
        <button id="btn-quality-up" onclick="increaseMaxQuality()">üìà Kalite +</button>
        <div id="quality-cap-label" style="font-size: 12px; opacity: 0.85; padding: 0 6px; white-space: nowrap;">Max: 720p</div>
        <button onclick="leaveRoom()">üö™ √áƒ±k</button>
    </div>
    
    <!-- Room Info -->
    <div id="room-info">
        <div id="room-name-display"></div>
        <div id="viewer-count"></div>
    </div>
    
    <!-- Sync Status -->
    <div id="sync-status">
        <span id="sync-text">Senkronize</span>
        <div id="sync-countdown" style="display: none; margin-top: 5px; font-size: 18px; font-weight: bold;"></div>
    </div>
    
    <!-- P2P Status -->
    <div id="p2p-status">
        <div style="display:flex; justify-content:space-between; gap:10px;">
            <div id="p2p-mode-label">P2P</div>
            <div id="p2p-peers">0 peers</div>
        </div>
        <div id="p2p-progress-container"><div id="p2p-progress-bar"></div></div>
        <div style="margin-top:6px; opacity:0.9;">
            <span id="p2p-progress-text">0%</span>
            <span style="margin:0 6px;">‚Ä¢</span>
            <span id="p2p-speed">0 B/s</span>
        </div>
    </div>


    <!-- Buffer Timer -->
    <div id="buffer-timer"></div>
    
    <!-- Buffer Countdown -->
    <div id="buffer-countdown"></div>
    
    <!-- A-Frame Scene -->
    <a-scene vr-mode-ui="enabled: true" loading-screen="enabled: false">
        <a-assets></a-assets>
        
        <!-- Camera with cursor for VR interaction (optimized) -->
        <a-camera position="0 1.6 0">
            <a-cursor
                id="vr-cursor"
                color="#4ade80"
                raycaster="objects: .clickable; interval: 1000; far: 5"
                fuse="false"
                visible="false">
            </a-cursor>
        </a-camera>
        
        <!-- Lighting (minimal for performance) -->
        <a-light type="ambient" color="#BBB" intensity="0.5"></a-light>
    </a-scene>
    
    <script>
        let isSeeking = false;
        let isHardSeeking = false; // ‚úÖ FIX: syncVideo ve listenKeyframes √ßakƒ±≈ümasƒ±nƒ± √∂nlemek i√ßin

        
        // ==================== CONFIG ====================
        // Firebase Yapƒ±landƒ±rmasƒ±
const firebaseConfig = {
    apiKey: "AIzaSyC60idSLdAiqAjPWAOMaM3g8LAKPGEUwH8",
    authDomain: "vr-sinema.firebaseapp.com",
    databaseURL: "https://vr-sinema-default-rtdb.firebaseio.com",
    projectId: "vr-sinema",
    storageBucket: "vr-sinema.firebasestorage.app",
    messagingSenderId: "724648238300",
    appId: "1:724648238300:web:dceba8c536e8a5ffd96819"
};
        
        // ==================== OPTIMIZED CONSTANTS ====================
        const SYNCCHECKINTERVAL = 750; // ‚úÖ FIX: drift timing sorunu i√ßin artƒ±rƒ±ldƒ±
        const KEYFRAME_INTERVAL = 10000;
        const CLOCK_SYNC_INTERVAL = 60000;
        const DRIFT_UPDATE_INTERVAL = 10000;
        const PRESENCE_UPDATE_INTERVAL = 30000;
        const CLEANUP_INTERVAL = 10000;
        const PLAY_BUFFER_TIME = 5000;
        const PRELOAD_BUFFER_SECONDS = 9; // ‚úÖ FIX: 7 -> 9 saniye buffer
        
        // Optimized thresholds
        const TIER1_THRESHOLD = 300;
        const TIER2_THRESHOLD = 800;
        const TIER3_THRESHOLD = 1500;
        const TIER2_LAGGING_SPEED = 1.05;
        const TIER3_LAGGING_SPEED = 1.15;
        
        // Hard seek throttle sabitleri
        const LARGE_DRIFT_THRESHOLD = 9000; // ‚úÖ FIX: 3000 -> 9000ms (9sn sonra hard seek)
        const HARD_SEEK_MIN_INTERVAL = 2000;
        
        const OWNER_PRESENCE_UPDATE_INTERVAL = 30000;
        const OWNER_PRESENCE_TIMEOUT = 45000;
        const DEBUG_MODE = true;
        
        // ==================== GLOBAL STATE ====================
        let db, auth, currentUser, currentRoomId, currentRoomData;
        let videoElement, isRoomOwner = false;
        let clockOffset = 0;
        

        // ==================== AUTH HELPERS ====================
        // Ensure Firebase Auth (anonymous) is ready before any RTDB write that requires auth
        async function ensureAuthReady() {
            if (auth && auth.currentUser) {
                currentUser = auth.currentUser;
                return currentUser;
            }
            try {
                await ensureAuthReady();
                if (!currentUser) throw new Error('AUTH_NOT_READY');

                return currentUser;
            } catch (e) {
                console.warn('Anonymous auth failed:', e);
                return null;
            }
        }

        // Interval tracking for cleanup (Memory Leak Prevention)
        const activeIntervals = [];
        const activeTimeouts = [];
        const firebaseListeners = [];
        
        // Performance optimization
        let lastDriftValue = null;
        let lastFirebaseUpdate = 0;
        let lastUIUpdate = 0;
        
        // Hard seek throttle tracking
        let lastHardSeekTime = 0;
        let lastSyncedPosition = 0;
        
        // Command source tracking (to prevent self-triggering)
        let lastCommandSource = null;
        
        // Sync mechanism
        let syncState = null;
        let countdownInterval = null;
        let syncTimeoutId = null;
        let lastSyncCheck = 0;
        
        // Buffer countdown system
        let bufferCountdownInterval = null;
        let bufferTargetTime = null;
        let isBuffering = false;
        
        // Cached DOM elements
        let cachedElements = {};
        
        // Firebase batch updates
        let pendingFirebaseUpdates = {};
        let firebaseBatchTimeout = null;

        // ‚úÖ FIX #3: joinRoom yarƒ±≈ümasƒ± √∂nleme
        let isJoiningRoom = false;
        
        // ‚úÖ FIX #8: onDisconnect referansƒ±
        let currentOnDisconnectRef = null;
        
        // ‚úÖ FIX #7: hashchange listener referansƒ±
        let hashChangeHandler = null;

        // ‚úÖ FIX: Scene ve keyboard listener referanslarƒ± (cleanup i√ßin)
        let sceneEnterVRHandler = null;
        let sceneExitVRHandler = null;
        let keydownHandler = null;

        let seekDebounceTimer = null;
        let pendingSeekAmount = 0;
        let pendingSeekDirection = null;
        let syncModeActive = false;
        let seekTimeoutId = null;
        let commandSourceTimeoutId = null;
        let videoStateUpdateDebounce = null;

        // ‚úÖ MEMORY LEAK FIX: Object URL tracking
        let currentVideoObjectURL = null;
        
        // ==================== P2P (WebTorrent) ====================
                const P2P_TRACKERS = [
            'wss://tracker.openwebtorrent.com/announce',
            'wss://tracker.fastcast.nz/announce',
            'wss://tracker.webtorrent.dev/announce'
        ];
        let p2pClient = null;
        let p2pTorrent = null;
        let p2pMagnetURI = null;
        let p2pProgressInterval = null;


        // ‚úÖ Owner transfer tracking
        let ownerTransferInProgress = false;

// ==================== ADAPTIVE STREAMING (ABR) ====================
let hlsInstance = null;
let dashInstance = null;

// Start as low as possible, cap max at <= 720p (user adjustable)
const QUALITY_CAPS = [360, 480, 720];
let abrMaxHeightCap = 720;

function getStreamType(url) {
    const u = (url || '').split('?')[0].toLowerCase();
    if (u.endsWith('.m3u8')) return 'hls';
    if (u.endsWith('.mpd')) return 'dash';
    return 'native';
}

function destroyAdaptiveStreaming() {
    try {
        if (hlsInstance) {
            hlsInstance.destroy();
            hlsInstance = null;
        }
    } catch (e) {}

    try {
        if (dashInstance) {
            dashInstance.reset();
            dashInstance = null;
        }
    } catch (e) {}
}

function updateQualityCapUI() {
    const label = getCachedElement('quality-cap-label');
    if (label) label.textContent = `Max: ${abrMaxHeightCap}p`;

    const upBtn = getCachedElement('btn-quality-up');
    const downBtn = getCachedElement('btn-quality-down');
    if (upBtn) upBtn.disabled = abrMaxHeightCap >= 720;
    if (downBtn) downBtn.disabled = abrMaxHeightCap <= QUALITY_CAPS[0];
}

function setMaxQualityCap(newCap) {
    abrMaxHeightCap = Math.max(QUALITY_CAPS[0], Math.min(720, newCap));
    updateQualityCapUI();
    applyAdaptiveCap();
}

function increaseMaxQuality() {
    const idx = QUALITY_CAPS.indexOf(abrMaxHeightCap);
    const next = idx === -1 ? 720 : QUALITY_CAPS[Math.min(QUALITY_CAPS.length - 1, idx + 1)];
    setMaxQualityCap(next);
}

function decreaseMaxQuality() {
    const idx = QUALITY_CAPS.indexOf(abrMaxHeightCap);
    const next = idx === -1 ? 480 : QUALITY_CAPS[Math.max(0, idx - 1)];
    setMaxQualityCap(next);
}

function applyAdaptiveCap() {
    if (hlsInstance) {
        applyHlsCap();
    }
    if (dashInstance) {
        applyDashCap();
    }
}

function applyHlsCap() {
    if (!hlsInstance || !hlsInstance.levels || hlsInstance.levels.length === 0) return;

    let capIndex = -1;
    for (let i = 0; i < hlsInstance.levels.length; i++) {
        const h = hlsInstance.levels[i].height || 0;
        if (h > 0 && h <= abrMaxHeightCap) capIndex = i;
    }

    if (capIndex === -1) {
        // If levels don't expose height, just cap to the top level (best effort)
        capIndex = hlsInstance.levels.length - 1;
    }

    hlsInstance.autoLevelCapping = capIndex;

    // If currently above cap, force next segment down
    if (hlsInstance.currentLevel > capIndex) {
        hlsInstance.nextAutoLevel = capIndex;
    }
}

function normalizeKbps(value) {
    if (!isFinite(value) || isNaN(value)) return null;
    // dash.js commonly uses kbps, but guard if bits/s slipped in
    if (value > 100000) return Math.round(value / 1000);
    return Math.round(value);
}

function applyDashCap() {
    if (!dashInstance) return;

    let list = [];
    try {
        list = dashInstance.getBitrateInfoListFor('video') || [];
    } catch (e) {
        list = [];
    }
    if (!list.length) return;

    const kbpsValues = list.map(i => normalizeKbps(i.bitrate)).filter(v => v !== null);
    if (!kbpsValues.length) return;

    const minKbps = Math.min(...kbpsValues);

    const candidates = list
        .filter(i => (i.height || 0) > 0 && i.height <= abrMaxHeightCap)
        .map(i => normalizeKbps(i.bitrate))
        .filter(v => v !== null);

    const maxKbps = candidates.length ? Math.max(...candidates) : minKbps;

    // Start low, keep min low, cap max to selected threshold
    dashInstance.updateSettings({
        streaming: {
            abr: {
                initialBitrate: { audio: -1, video: minKbps },
                minBitrate: { audio: -1, video: minKbps },
                maxBitrate: { audio: -1, video: maxKbps }
            },
            buffer: {
                fastSwitchEnabled: true
            }
        }
    });
}

function setupAdaptiveSource(url) {
    if (!videoElement) return;

    destroyAdaptiveStreaming();

    const type = getStreamType(url);

    if (type === 'hls') {
        if (window.Hls && Hls.isSupported()) {
            hlsInstance = new Hls({
                startLevel: 0, // start from lowest
                minAutoBitrate: 0, // allow lowest
                abrEwmaDefaultEstimate: 150000, // very low initial estimate (bps)
                abrBandWidthFactor: 0.9, // ‚úÖ FIX: 0.8 -> 0.9 (kalite d√º≈ü√ºrme i√ßin daha muhafazakar)
                abrBandWidthUpFactor: 0.6 // ‚úÖ FIX: 0.7 -> 0.6 (yukarƒ± ge√ßi≈üte daha dikkatli)
            });

            hlsInstance.on(Hls.Events.MANIFEST_PARSED, () => {
                applyHlsCap();
                updateQualityCapUI();
            });

            hlsInstance.attachMedia(videoElement);
            hlsInstance.loadSource(url);
            return;
        }

        // Safari / native HLS support
        videoElement.src = url;
        updateQualityCapUI();
        return;
    }

    if (type === 'dash') {
        if (window.dashjs && dashjs.MediaPlayer) {
            dashInstance = dashjs.MediaPlayer().create();

            dashInstance.updateSettings({
                streaming: {
                    abr: {
                        initialBitrate: { audio: -1, video: 150 }, // kbps
                        minBitrate: { audio: -1, video: 100 },
                        maxBitrate: { audio: -1, video: 2500 } // will be recalculated on init
                    },
                    buffer: {
                        fastSwitchEnabled: true
                    }
                }
            });

            dashInstance.on(dashjs.MediaPlayer.events.STREAM_INITIALIZED, () => {
                applyDashCap();
                updateQualityCapUI();
            });

            dashInstance.initialize(videoElement, url, false);
            return;
        }

        videoElement.src = url;
        updateQualityCapUI();
        return;
    }

    // Native progressive (mp4/webm/etc.)
    videoElement.src = url;
    updateQualityCapUI();
}

// ==================== P2P (WebTorrent) ====================
function isWebTorrentSupported() {
    return window.WebTorrent && WebTorrent.WEBRTC_SUPPORT;
}

function initP2PClientIfNeeded() {
    if (!isWebTorrentSupported()) {
        console.warn('WebTorrent/WebRTC not supported in this browser.');
        return null;
    }
    if (!p2pClient) {
        p2pClient = new WebTorrent();
        p2pClient.on('error', (err) => {
            console.warn('WebTorrent client error:', err);
        });
    }
    return p2pClient;
}

function cleanupP2P() {
    try {
        if (p2pProgressInterval) {
            clearInterval(p2pProgressInterval);
            p2pProgressInterval = null;
        }
        if (p2pTorrent) {
            try { p2pTorrent.destroy(); } catch (e) {}
            p2pTorrent = null;
        }
        if (p2pClient) {
            try { p2pClient.destroy(); } catch (e) {}
            p2pClient = null;
        }
        p2pMagnetURI = null;
        hideP2PStatus();
    } catch (e) {
        console.warn('P2P cleanup error:', e);
    }
}

function showP2PStatus() {
    const el = getCachedElement('p2p-status');
    if (el) el.style.display = 'block';
}

function hideP2PStatus() {
    const el = getCachedElement('p2p-status');
    if (el) el.style.display = 'none';
}

function setP2PStatusUI({ modeText, peersText, progressPct, speedText }) {
    const modeEl = getCachedElement('p2p-mode-label');
    const peersEl = getCachedElement('p2p-peers');
    const progressEl = getCachedElement('p2p-progress-text');
    const speedEl = getCachedElement('p2p-speed');
    const barEl = getCachedElement('p2p-progress-bar');

    if (modeEl && modeText != null) modeEl.textContent = modeText;
    if (peersEl && peersText != null) peersEl.textContent = peersText;
    if (progressEl && progressPct != null) progressEl.textContent = `${progressPct}%`;
    if (speedEl && speedText != null) speedEl.textContent = speedText;
    if (barEl && progressPct != null) barEl.style.width = `${progressPct}%`;
}

function formatBytesPerSecond(bps) {
    const n = Number(bps) || 0;
    const units = ['B/s', 'KB/s', 'MB/s', 'GB/s'];
    let v = n;
    let u = 0;
    while (v >= 1024 && u < units.length - 1) {
        v /= 1024;
        u++;
    }
    return `${v.toFixed(u === 0 ? 0 : 1)} ${units[u]}`;
}

function pickBestVideoFile(files) {
    if (!files || !files.length) return null;

    const preferredExt = ['.mp4', '.webm', '.mkv', '.mov', '.m4v', '.ogv', '.ogg'];
    const byExt = files.find(f => preferredExt.some(ext => f.name.toLowerCase().endsWith(ext)));
    if (byExt) return byExt;

    // fallback: pick largest file
    return files.slice().sort((a, b) => (b.length || 0) - (a.length || 0))[0];
}

async function seedLocalVideo(file) {
    if (!currentRoomId || !db) return;


    await ensureAuthReady();
    const client = initP2PClientIfNeeded();
    if (!client) {
        alert('Bu tarayƒ±cƒ± P2P (WebTorrent/WebRTC) desteklemiyor.');
        return;
    }

    cleanupP2P(); // ensure clean state, then recreate client
    const freshClient = initP2PClientIfNeeded();
    if (!freshClient) return;

    showP2PStatus();
    setP2PStatusUI({
        modeText: 'Seeding',
        peersText: '0 peers',
        progressPct: 0,
        speedText: '0 B/s'
    });

    return new Promise((resolve) => {
        freshClient.seed(file, { announce: P2P_TRACKERS }, async (torrent) => {
            p2pTorrent = torrent;
            p2pMagnetURI = torrent.magnetURI;

            try {
                await db.ref('rooms/' + currentRoomId + '/torrent').update({
                    magnetURI: torrent.magnetURI
                });
            } catch (e) {
                console.warn('Failed to write magnetURI:', e);
            }

            const chosen = pickBestVideoFile(torrent.files);
            if (chosen && videoElement) {
                try {
                    destroyAdaptiveStreaming();
                    revokeCurrentVideoURL();
                    videoElement.removeAttribute('src');
                    videoElement.load();
                    chosen.streamTo(videoElement);
                } catch (e) {
                    console.warn('P2P stream error:', e);
                }
            }

            // UI updates
            if (p2pProgressInterval) clearInterval(p2pProgressInterval);
            p2pProgressInterval = trackInterval(setInterval(() => {
                if (!p2pTorrent) return;
                const peers = p2pTorrent.numPeers || 0;
                const pct = Math.floor((p2pTorrent.progress || 0) * 100);
                setP2PStatusUI({
                    modeText: 'Seeding',
                    peersText: `${peers} peers`,
                    progressPct: pct,
                    speedText: `‚Üë ${formatBytesPerSecond(p2pTorrent.uploadSpeed)}`
                });
            }, 800));

            torrent.on('error', (err) => console.warn('Torrent error:', err));
            resolve();
        });
    });
}

function joinP2PTorrent(magnetURI) {
    if (!magnetURI || !currentRoomId) return;
    if (p2pMagnetURI && p2pMagnetURI === magnetURI && p2pTorrent) return;

    const client = initP2PClientIfNeeded();
    if (!client) {
        alert('Bu tarayƒ±cƒ± P2P (WebTorrent/WebRTC) desteklemiyor.');
        return;
    }

    // If we were already in another torrent, clean up first
    cleanupP2P();
    const freshClient = initP2PClientIfNeeded();
    if (!freshClient) return;

    p2pMagnetURI = magnetURI;
    showP2PStatus();
    setP2PStatusUI({
        modeText: 'Downloading',
        peersText: '0 peers',
        progressPct: 0,
        speedText: '0 B/s'
    });

    freshClient.add(magnetURI, { announce: P2P_TRACKERS }, (torrent) => {
        p2pTorrent = torrent;

        const chosen = pickBestVideoFile(torrent.files);
        if (chosen && videoElement) {
            try {
                destroyAdaptiveStreaming();
                revokeCurrentVideoURL();
                videoElement.removeAttribute('src');
                videoElement.load();
                chosen.streamTo(videoElement);
            } catch (e) {
                console.warn('P2P stream error:', e);
            }
        }

        if (p2pProgressInterval) clearInterval(p2pProgressInterval);
        p2pProgressInterval = trackInterval(setInterval(() => {
            if (!p2pTorrent) return;
            const peers = p2pTorrent.numPeers || 0;
            const pct = Math.floor((p2pTorrent.progress || 0) * 100);
            setP2PStatusUI({
                modeText: p2pTorrent.done ? 'Seeding' : 'Downloading',
                peersText: `${peers} peers`,
                progressPct: pct,
                speedText: `‚Üì ${formatBytesPerSecond(p2pTorrent.downloadSpeed)} ‚Ä¢ ‚Üë ${formatBytesPerSecond(p2pTorrent.uploadSpeed)}`
            });
        }, 800));

        torrent.on('error', (err) => console.warn('Torrent error:', err));
    });
}

function listenP2PMagnetURI() {
    if (!currentRoomId || !db) return;

    const magnetRef = db.ref('rooms/' + currentRoomId + '/torrent/magnetURI');
    trackListener(magnetRef);

    magnetRef.on('value', (snapshot) => {
        const magnetURI = snapshot.val();
        if (!currentRoomData) return;

        currentRoomData.torrent = currentRoomData.torrent || {};
        currentRoomData.torrent.magnetURI = magnetURI;

        if (magnetURI) {
            joinP2PTorrent(magnetURI);
        } else {
            // No magnet -> fall back to URL workflow (if available)
            hideP2PStatus();
            if (currentRoomData.videoUrl) {
                if (typeof currentRoomData.videoUrl === 'string' && currentRoomData.videoUrl.startsWith('p2p://')) {
            // P2P placeholder: source will be provided by WebTorrent when magnetURI arrives
        } else {
            setupAdaptiveSource(currentRoomData.videoUrl);
        }
            }
        }
    });
}


        function setCommandSourceSelf() {
            if (commandSourceTimeoutId) {
                clearTimeout(commandSourceTimeoutId);
            }
            lastCommandSource = 'self';
            commandSourceTimeoutId = setTimeout(() => {
                lastCommandSource = null;
                commandSourceTimeoutId = null;
            }, 2000);
        }

        function updateVideoState(updates) {
            if (videoStateUpdateDebounce) {
                clearTimeout(videoStateUpdateDebounce);
            }
            
            videoStateUpdateDebounce = setTimeout(() => {
                setCommandSourceSelf();
                db.ref(`rooms/${currentRoomId}/videoState`).update(updates);
                videoStateUpdateDebounce = null;
            }, 200);
        }


function seekBackward() {
    if (!isRoomOwner || !videoElement) return;

    pendingSeekAmount -= 10;

    if (seekDebounceTimer) {
        clearTimeout(seekDebounceTimer);
    }

    seekDebounceTimer = setTimeout(() => {
        executeSeek('backward', pendingSeekAmount);
        seekDebounceTimer = null;
        pendingSeekAmount = 0;
    }, 500);
}

function seekForward() {
    if (!isRoomOwner || !videoElement) return;

    pendingSeekAmount += 10;

    if (seekDebounceTimer) {
        clearTimeout(seekDebounceTimer);
    }

    seekDebounceTimer = setTimeout(() => {
        executeSeek('forward', pendingSeekAmount);
        seekDebounceTimer = null;
        pendingSeekAmount = 0;
    }, 500);
}

function executeSeek(direction, totalAmount) {
    if (!videoElement || isSeeking) return;

    if (videoElement.readyState < 1) {
        console.warn('Video metadata not loaded yet');
        return;
    }

    isSeeking = true;

    const targetTime = Math.max(0, Math.min(videoElement.duration || Infinity, videoElement.currentTime + totalAmount));

    lastCommandSource = 'self';
    videoElement.pause();

    let seekCompleted = false;

    const onSeeked = () => {
        if (seekCompleted) return;
        seekCompleted = true;
        videoElement.removeEventListener('seeked', onSeeked);

        const newPos = videoElement.currentTime;
        const updates = {
            'videoState/isPlaying': false,
            'videoState/currentTime': newPos,
            'videoState/startTimestamp': getServerTime(),
            'videoState/lastUpdate': firebase.database.ServerValue.TIMESTAMP,
            'keyframes': null,
            'syncState': null
        };

        db.ref(`rooms/${currentRoomId}`).update(updates)
            .then(() => {
                debugLog(`Seek ${direction} complete, paused at`, newPos);
                isSeeking = false;
            })
            .catch(err => {
                console.warn('Seek update error:', err);
                isSeeking = false;
            });

        // ‚úÖ FIX: Timeout'u track et
        trackTimeout(setTimeout(() => { lastCommandSource = null; }, 2500));
    };

    videoElement.addEventListener('seeked', onSeeked);
    videoElement.currentTime = targetTime;

    // ‚úÖ FIX: Timeout'u track et
    trackTimeout(setTimeout(() => {
        if (!seekCompleted) {
            isSeeking = false;
            debugLog('Seek timeout - forcing completion');
            onSeeked();
        }
    }, 2000));
}



        // ==================== FIREBASE INIT ====================
        firebase.initializeApp(firebaseConfig);
        db = firebase.database();
        auth = firebase.auth();
        
        // ==================== HELPER FUNCTIONS ====================
        function debugLog(...args) {
            if (DEBUG_MODE) console.log(...args);
        }
        

        // requestAnimationFrame queue limiter
        let rafQueue = [];
        let rafScheduled = false;
        
        function queueRAF(callback) {
            rafQueue.push(callback);
            if (!rafScheduled) {
                rafScheduled = true;
                requestAnimationFrame(() => {
                    const callbacks = rafQueue.splice(0);
                    rafScheduled = false;
                    callbacks.forEach(cb => {
                        try { cb(); } catch(e) { console.warn('RAF callback error:', e); }
                    });
                });
            }
        }
        
        
        function getServerTime() {
            return Date.now() + clockOffset;
        }
        
        // DOM Element Caching
        function getCachedElement(id) {
            if (!cachedElements[id]) {
                cachedElements[id] = document.getElementById(id);
            }
            return cachedElements[id];
        }
        
        function clearElementCache() {
            cachedElements = {};
        }
        
        // ==================== MEMORY LEAK PREVENTION ====================
        function trackInterval(id) {
            if (id) activeIntervals.push(id);
            return id;
        }
        
        function trackTimeout(id) {
            if (id) activeTimeouts.push(id);
            return id;
        }
        
        function trackListener(ref) {
            if (ref) firebaseListeners.push(ref);
            return ref;
        }
        
        // ‚úÖ FIX #7 & #11: T√ºm interval'larƒ± temizle
        function clearAllIntervals() {
            // Buffer countdown temizle
            if (bufferCountdownInterval) {
                clearInterval(bufferCountdownInterval);
                bufferCountdownInterval = null;
            }
            
            // Countdown interval temizle
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            
            // Seek debounce timer temizle
            if (seekDebounceTimer) {
                clearTimeout(seekDebounceTimer);
                seekDebounceTimer = null;
            }
            
            activeIntervals.forEach(id => clearInterval(id));
            activeIntervals.length = 0;
        }
        
        function clearAllTimeouts() {
            // Sync timeout temizle
            if (syncTimeoutId) {
                clearTimeout(syncTimeoutId);
                syncTimeoutId = null;
            }
            
            // Command source timeout temizle
            if (commandSourceTimeoutId) {
                clearTimeout(commandSourceTimeoutId);
                commandSourceTimeoutId = null;
            }
            
            // Video state update debounce temizle
            if (videoStateUpdateDebounce) {
                clearTimeout(videoStateUpdateDebounce);
                videoStateUpdateDebounce = null;
            }
            
            // Firebase batch timeout temizle
            if (firebaseBatchTimeout) {
                clearTimeout(firebaseBatchTimeout);
                firebaseBatchTimeout = null;
            }
            
            activeTimeouts.forEach(id => clearTimeout(id));
            activeTimeouts.length = 0;
        }
        
        function clearAllListeners() {
            firebaseListeners.forEach(ref => {
                try {
                    ref.off();
                } catch (e) {
                    console.warn('Listener cleanup error:', e);
                }
            });
            firebaseListeners.length = 0;
        }
        
        // ‚úÖ FIX #1: Video listener'larƒ±nƒ± temizle (ayrƒ± fonksiyon)
        function clearVideoListeners() {
            if (!videoElement) return;
            
            if (videoElement._listeners && videoElement._listeners.length > 0) {
                videoElement._listeners.forEach(({ event, handler }) => {
                    videoElement.removeEventListener(event, handler);
                });
                videoElement._listeners = [];
                debugLog('üßπ Video listeners cleared:', videoElement._listeners.length);
            }
            
            // Legacy cleanup
            if (videoElement._eventListeners) {
                videoElement._eventListeners.forEach(([event, listener]) => {
                    videoElement.removeEventListener(event, listener);
                });
                videoElement._eventListeners = [];
            }
        }
        
        // ‚úÖ MEMORY LEAK FIX: Object URL temizleme
        function revokeCurrentVideoURL() {
            if (currentVideoObjectURL) {
                URL.revokeObjectURL(currentVideoObjectURL);
                currentVideoObjectURL = null;
                debugLog('üßπ Object URL revoked');
            }
        }
        
        // ‚úÖ FIX #7 & #8: hashchange ve onDisconnect temizleme
        function fullCleanup() {
            // ‚úÖ ABR cleanup
            destroyAdaptiveStreaming();

            // ‚úÖ P2P cleanup
            cleanupP2P();


            // Flush pending Firebase updates first
            if (firebaseBatchTimeout) {
                clearTimeout(firebaseBatchTimeout);
                flushFirebaseUpdates();
            }
            
            // ‚úÖ FIX: Owner task'larƒ±nƒ± temizle
            clearOwnerTasks();
            
            clearAllIntervals();
            clearAllTimeouts();
            clearAllListeners();
            clearElementCache();
            
            // ‚úÖ FIX #7: hashchange listener kaldƒ±r
            if (hashChangeHandler) {
                window.removeEventListener('hashchange', hashChangeHandler);
                hashChangeHandler = null;
            }
            
            // ‚úÖ FIX: Scene listener'larƒ± kaldƒ±r
            const scene = document.querySelector('a-scene');
            if (scene) {
                if (sceneEnterVRHandler) {
                    scene.removeEventListener('enter-vr', sceneEnterVRHandler);
                    sceneEnterVRHandler = null;
                }
                if (sceneExitVRHandler) {
                    scene.removeEventListener('exit-vr', sceneExitVRHandler);
                    sceneExitVRHandler = null;
                }
            }
            
            // ‚úÖ FIX: Keyboard listener kaldƒ±r
            if (keydownHandler) {
                document.removeEventListener('keydown', keydownHandler);
                keydownHandler = null;
            }
            
            // ‚úÖ FIX #8: onDisconnect referansƒ±nƒ± iptal et
            if (currentOnDisconnectRef) {
                currentOnDisconnectRef.cancel().catch(() => {});
                currentOnDisconnectRef = null;
            }
            
            // ‚úÖ MEMORY LEAK FIX: Object URL temizle
            revokeCurrentVideoURL();
            
            // Remove from active viewers
            if (currentRoomId && currentUser) {
                db.ref('rooms/' + currentRoomId + '/activeViewers/' + currentUser.uid).remove().catch(() => {});
            }
            
            pendingFirebaseUpdates = {};
            
            // Reset tracking variables
            lastHardSeekTime = 0;
            lastSyncedPosition = 0;
            isJoiningRoom = false;
            isHardSeeking = false; // ‚úÖ FIX: Reset isHardSeeking
            ownerTransferInProgress = false;
            
            debugLog('üßπ Full cleanup completed');
        }
        
        // ==================== FIREBASE BATCH UPDATES ====================
        function queueFirebaseUpdate(path, value) {
            pendingFirebaseUpdates[path] = value;
            
            if (!firebaseBatchTimeout) {
                firebaseBatchTimeout = setTimeout(() => {
                    flushFirebaseUpdates();
                }, 1000);
            }
        }
        
        function flushFirebaseUpdates() {
            if (Object.keys(pendingFirebaseUpdates).length > 0 && currentRoomId) {
                db.ref('rooms/' + currentRoomId)
                    .update(pendingFirebaseUpdates)
                    .catch(err => console.warn('Batch update error:', err));
                
                pendingFirebaseUpdates = {};
            }
            firebaseBatchTimeout = null;
        }
        
        function shouldUpdateFirebase() {
            const now = Date.now();
            if (now - lastFirebaseUpdate < 5000) {
                return false;
            }
            lastFirebaseUpdate = now;
            return true;
        }
        
        function shouldUpdateUI() {
            const now = Date.now();
            if (now - lastUIUpdate < 300) {
                return false;
            }
            lastUIUpdate = now;
            return true;
        }
        
        // ==================== CLOCK SYNC ====================
        async function initClockSync() {
            try {
                const samples = [];
                for (let i = 0; i < 3; i++) {
                    const t0 = Date.now();
                    const ref = db.ref('.info/serverTimeOffset');
                    const snapshot = await ref.once('value');
                    const offset = snapshot.val();
                    const t1 = Date.now();
                    const rtt = t1 - t0;
                    const serverTime = Date.now() + offset;
                    const calculatedOffset = serverTime - (t0 + rtt / 2);
                    samples.push(calculatedOffset);
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                clockOffset = samples.reduce((a, b) => a + b, 0) / samples.length;
                debugLog('üïê Clock offset:', clockOffset, 'ms');
            } catch (error) {
                console.warn('Clock sync error:', error);
            }
        }
        
        // ==================== ROOM MANAGEMENT ====================
        async function createRoom() {
            const roomName = getCachedElement('room-name').value.trim();
            const videoUrl = getCachedElement('video-url').value.trim();
            const videoFileInput = getCachedElement('video-file');
            const localFile = videoFileInput && videoFileInput.files ? videoFileInput.files[0] : null;
            const screenSize = getCachedElement('screen-size').value;
            const environment = getCachedElement('environment').value;
            
            if (!roomName || (!videoUrl && !localFile)) {
                alert('L√ºtfen oda adƒ± ve video URL giriniz veya lokal dosya se√ßiniz!');
                return;
            }
            
            try {
                const userCredential = await auth.signInAnonymously();
                currentUser = userCredential.user;
                
                const roomRef = db.ref('rooms').push();
                currentRoomId = roomRef.key;
                
                await roomRef.set({
                    name: roomName,
                    owner: currentUser.uid,
                    videoUrl: videoUrl || (localFile ? 'p2p://local' : ''),
                    torrent: { magnetURI: null },
                    screenSize: screenSize,
                    environment: environment,
                    createdAt: firebase.database.ServerValue.TIMESTAMP,
                    videoState: {
                        isPlaying: false,
                        currentTime: 0,
                        startTimestamp: 0,
                        lastUpdate: firebase.database.ServerValue.TIMESTAMP
                    }
                });
                
                await joinRoom(currentRoomId);
                if (localFile) {
                    await seedLocalVideo(localFile);
                }
            } catch (error) {
                console.error('‚ùå Oda olu≈üturma hatasƒ±:', error);
                alert('Oda olu≈üturulamadƒ±: ' + error.message);
            }
        }
        
        // ‚úÖ FIX #3: joinRoom race condition √∂nleme
        async function joinRoom(roomId) {
            // ‚úÖ FIX #3: Yarƒ±≈üma √∂nleme - zaten katƒ±lƒ±m varsa √ßƒ±k
            if (isJoiningRoom) {
                debugLog('‚ö†Ô∏è Already joining a room, skipping duplicate call');
                return;
            }
            isJoiningRoom = true;
            
            try {
                if (!auth.currentUser) {
                    const userCredential = await auth.signInAnonymously();
                    currentUser = userCredential.user;
                } else {
                    currentUser = auth.currentUser;
                }
                
                // ‚úÖ FIX #8: √ñnceki onDisconnect'i iptal et
                if (currentOnDisconnectRef) {
                    await currentOnDisconnectRef.cancel().catch(() => {});
                    currentOnDisconnectRef = null;
                }
                
                currentRoomId = roomId;
                const roomSnapshot = await db.ref('rooms/' + roomId).once('value');
                currentRoomData = roomSnapshot.val();
                
                if (!currentRoomData) {
                    alert('Oda bulunamadƒ±!');
                    isJoiningRoom = false;
                    return;
                }
                
                // ‚úÖ Sahiplik kontrol√º: Mevcut owner ile kar≈üƒ±la≈ütƒ±r
                isRoomOwner = currentUser.uid === currentRoomData.owner;
                
                // Add to active viewers
                const viewerRef = db.ref('rooms/' + roomId + '/activeViewers/' + currentUser.uid);
                await viewerRef.set({
                    joinedAt: firebase.database.ServerValue.TIMESTAMP,
                    lastSeen: firebase.database.ServerValue.TIMESTAMP,
                    isOwner: isRoomOwner,
                    currentDrift: 0
                });
                
                // ‚úÖ FIX #8: onDisconnect referansƒ±nƒ± sakla
                currentOnDisconnectRef = viewerRef.onDisconnect();
                currentOnDisconnectRef.remove();
                
                await initClockSync();
                await create3DScene();
                
                getCachedElement('ui-overlay').classList.add('hidden');
                getCachedElement('vr-controls').style.display = 'flex';
                getCachedElement('room-info').style.display = 'block';
                getCachedElement('sync-status').style.display = 'block';
                
                updateRoomInfoDisplay();
                listenVideoState();
                listenSyncState();
                listenP2PMagnetURI();
                
                // ‚úÖ Sahip ayrƒ±lma listener'ƒ± - herkes i√ßin
                listenOwnerLeft();
                
                if (isRoomOwner) {
                    startOwnerTasks();
                } else {
                    listenKeyframes();
                }
                
                // Start all periodic tasks
                startPeriodicTasks();
                
                isJoiningRoom = false;
                
            } catch (error) {
                console.error('‚ùå Odaya katƒ±lma hatasƒ±:', error);
                alert('Odaya katƒ±lƒ±namadƒ±: ' + error.message);
                isJoiningRoom = false;
            }
        }
        
        // ‚úÖ YENƒ∞: Oda sahibi ayrƒ±ldƒ±ƒüƒ±nda yeni sahip atama
        function listenOwnerLeft() {
            const viewersRef = db.ref('rooms/' + currentRoomId + '/activeViewers');
            trackListener(viewersRef);
            
            viewersRef.on('value', async (snapshot) => {
                if (!currentRoomId || !currentUser || ownerTransferInProgress) return;
                
                const viewers = snapshot.val();
                if (!viewers) return;
                
                // G√ºncel oda verisini al
                const roomSnapshot = await db.ref('rooms/' + currentRoomId).once('value');
                const roomData = roomSnapshot.val();
                if (!roomData) return;
                
                const currentOwnerUid = roomData.owner;
                
                // Mevcut sahip hala odada mƒ±?
                const ownerStillHere = viewers[currentOwnerUid] !== undefined;
                
                if (!ownerStillHere && Object.keys(viewers).length > 0) {
                    // Sahip ayrƒ±lmƒ±≈ü, yeni sahip ata
                    // En eski katƒ±lƒ±mcƒ±yƒ± bul (en d√º≈ü√ºk joinedAt)
                    let oldestViewer = null;
                    let oldestTime = Infinity;
                    
                    Object.keys(viewers).forEach(uid => {
                        const viewer = viewers[uid];
                        if (viewer.joinedAt && viewer.joinedAt < oldestTime) {
                            oldestTime = viewer.joinedAt;
                            oldestViewer = uid;
                        }
                    });
                    
                    // Eƒüer en eski katƒ±lƒ±mcƒ± bensem, sahipliƒüi al
                    if (oldestViewer === currentUser.uid) {
                        ownerTransferInProgress = true;
                        
                        try {
                            // Atomik g√ºncelleme: owner'ƒ± ve viewer'ƒ±mƒ± g√ºncelle
                            await db.ref('rooms/' + currentRoomId).update({
                                owner: currentUser.uid
                            });
                            
                            await db.ref('rooms/' + currentRoomId + '/activeViewers/' + currentUser.uid).update({
                                isOwner: true
                            });
                            
                            // Lokal state g√ºncelle
                            isRoomOwner = true;
                            currentRoomData.owner = currentUser.uid;
                            
                            // Owner task'larƒ±nƒ± ba≈ülat
                            startOwnerTasks();
                            
                            // Keyframe listener'ƒ± kapat (artƒ±k owner'ƒ±z)
                            // Not: listenKeyframes zaten trackListener ile eklendi, 
                            // ama owner olunca keyframe dinlemeye gerek yok
                            
                            console.log('üëë Sahiplik size devredildi!');
                            debugLog('üëë Ownership transferred to:', currentUser.uid);
                            
                            // UI g√ºncelle
                            updateRoomInfoDisplay();
                            
                        } catch (error) {
                            console.error('Sahiplik transfer hatasƒ±:', error);
                        } finally {
                            ownerTransferInProgress = false;
                        }
                    }
                }
            });
        }
        
        // ‚úÖ FIX #7: leaveRoom - t√ºm temizlikler
        function leaveRoom() {
            if (currentRoomId && currentUser) {
                db.ref('rooms/' + currentRoomId + '/activeViewers/' + currentUser.uid).remove();
            }
            
            // Clear sync state
            clearSyncState();
            
            // ‚úÖ FIX #1: Video listener'larƒ±nƒ± temizle
            clearVideoListeners();
            
            // Full cleanup (includes FIX #7 & #8)
            fullCleanup();
            
            // Clean up video element
            if (videoElement) {
                videoElement.pause();
                videoElement.removeAttribute('src');
                videoElement.load();
                videoElement.remove();
                videoElement = null;
            }
            
            // Remove scene elements with A-Frame cleanup
            const scene = document.querySelector('a-scene');
            const videoScreen = document.getElementById('video-screen');
            const vrPanel = document.getElementById('vr-panel');
            
            if (videoScreen) {
                const material = videoScreen.components.material;
                if (material && material.material && material.material.map) {
                    material.material.map.dispose();
                    material.material.dispose();
                }
                videoScreen.remove();
            }
            
            // ‚úÖ FIX: VR panel button listener'larƒ±nƒ± temizle
            if (vrPanel && vrPanel._buttonListeners) {
                vrPanel._buttonListeners.forEach(({ element, handler }) => {
                    element.removeEventListener('click', handler);
                });
                vrPanel._buttonListeners = [];
            }
            if (vrPanel) vrPanel.remove();
            
            getCachedElement('ui-overlay').classList.remove('hidden');
            getCachedElement('vr-controls').style.display = 'none';
            getCachedElement('room-info').style.display = 'none';
            getCachedElement('sync-status').style.display = 'none';
            const p2pEl = getCachedElement('p2p-status');
            if (p2pEl) p2pEl.style.display = 'none';
            
            const bufferEl = getCachedElement('buffer-countdown');
            if (bufferEl) bufferEl.style.display = 'none';
            
            isBuffering = false;
            bufferTargetTime = null;
            
            currentRoomId = null;
            currentRoomData = null;
            isRoomOwner = false;
            lastDriftValue = null;
        }
        
        async function showRoomList() {
            try {
                if (!auth.currentUser) {
                    await auth.signInAnonymously();
                }
                
                const roomsSnapshot = await db.ref('rooms').limitToLast(20).once('value');
                const roomList = getCachedElement('room-list');
                roomList.innerHTML = '';
                
                const rooms = [];
                const roomsToDelete = [];
                
                roomsSnapshot.forEach(child => {
                    const roomData = child.val();
                    const viewerCount = roomData.activeViewers ? Object.keys(roomData.activeViewers).length : 0;
                    
                    if (viewerCount === 0) {
                        roomsToDelete.push(child.key);
                    } else {
                        rooms.push({ id: child.key, data: roomData, viewers: viewerCount });
                    }
                });
                
                roomsToDelete.forEach(roomId => {
                    db.ref('rooms/' + roomId).remove();
                });
                
                if (rooms.length === 0) {
                    roomList.innerHTML = '<p style="text-align: center; opacity: 0.7;">Aktif oda bulunamadƒ±</p>';
                } else {
                    rooms.forEach(room => {
                        const roomDiv = document.createElement('div');
                        roomDiv.className = 'room-item';
                        roomDiv.innerHTML = `
                            <div class="room-name">${room.data.name}</div>
                            <div class="room-details">üë• ${room.viewers} izleyici</div>
                        `;
                        roomDiv.onclick = () => joinRoom(room.id);
                        roomList.appendChild(roomDiv);
                    });
                }
                
                getCachedElement('create-room-section').classList.add('hidden');
                getCachedElement('room-list-section').classList.remove('hidden');
                
            } catch (error) {
                console.error('‚ùå Oda listesi hatasƒ±:', error);
                alert('Odalar y√ºklenirken hata olu≈ütu: ' + error.message + '\n\nL√ºtfen Firebase Rules ayarlarƒ±nƒ±zƒ± kontrol edin.');
            }
        }
        
        function showCreateRoom() {
            getCachedElement('room-list-section').classList.add('hidden');
            getCachedElement('create-room-section').classList.remove('hidden');
        }
        
        // ==================== 3D SCENE ====================
        // ‚úÖ FIX #1 & #2: Video listener'larƒ± d√ºzg√ºn y√∂netim
        async function create3DScene() {
    const scene = document.querySelector('a-scene');
    const assets = document.querySelector('a-assets');

    revokeCurrentVideoURL();

    videoElement = document.createElement('video');
    videoElement.setAttribute('id', 'video-source');
    videoElement.setAttribute('crossorigin', 'anonymous');
    videoElement.setAttribute('playsinline', '');
    videoElement.setAttribute('webkit-playsinline', '');
    videoElement.setAttribute('preload', 'auto');

    videoElement.listeners = [];

    const handleLoadedMetadata = () => {
        debugLog('üìπ Video metadata loaded, duration:', videoElement.duration);
    };

    const handleError = (e) => {
        console.error('Video error:', e);
    };

    videoElement.addEventListener('loadedmetadata', handleLoadedMetadata);
    videoElement.addEventListener('error', handleError);

    videoElement.listeners.push(
        { event: 'loadedmetadata', handler: handleLoadedMetadata },
        { event: 'error', handler: handleError }
    );

    const initialMagnetURI = currentRoomData && currentRoomData.torrent ? currentRoomData.torrent.magnetURI : null;
    if (initialMagnetURI) {
        joinP2PTorrent(initialMagnetURI);
    } else {
        setupAdaptiveSource(currentRoomData.videoUrl);
    }

    const playListener = () => {
        if (syncState) return;
        if (currentRoomData.videoState && !currentRoomData.videoState.isPlaying) {
            syncVideoState();
        }
    };

    const pauseListener = () => {
        if (syncState) return;
        if (currentRoomData.videoState && currentRoomData.videoState.isPlaying) {
            syncVideoState();
        }
    };

    const seekedListener = () => {
        if (syncState || isSeeking) return;
        syncVideoState();
    };

    if (isRoomOwner) {
        videoElement.addEventListener('play', playListener);
        videoElement.addEventListener('pause', pauseListener);
        videoElement.addEventListener('seeked', seekedListener);

        videoElement.listeners.push(
            { event: 'play', handler: playListener },
            { event: 'pause', handler: pauseListener },
            { event: 'seeked', handler: seekedListener }
        );
    }

    assets.appendChild(videoElement);

    if (currentRoomData.environment === 'minimal') {
        const sky = document.createElement('a-sky');
        sky.setAttribute('color', '#000');
        scene.appendChild(sky);
    }

    const screenSizes = {
        medium: { width: 8, height: 4.5 },
        large: { width: 10, height: 4.76 },
        imax: { width: 7, height: 10 }
    };
    const size = screenSizes[currentRoomData.screenSize] || screenSizes.medium;

    const videoScreen = document.createElement('a-plane');
    videoScreen.setAttribute('id', 'video-screen');
    videoScreen.setAttribute('position', '0 2 -5');
    videoScreen.setAttribute('width', size.width);
    videoScreen.setAttribute('height', size.height);
    videoScreen.setAttribute('material', 'src: #video-source; shader: flat');
    videoScreen.setAttribute('video-texture-fix', '#video-source');
    scene.appendChild(videoScreen);

    if (isRoomOwner) {
        const panel = document.createElement('a-entity');
        panel.setAttribute('id', 'vr-panel');
        panel.setAttribute('position', '0 1 -2');

        const buttons = [
            { text: '‚ñ∂', position: '-0.6 0 0', event: 'play' },
            { text: '‚è∏', position: '-0.2 0 0', event: 'pause' },
            { text: '‚è™', position: '0.2 0 0', event: 'rewind' },
            { text: '‚è©', position: '0.6 0 0', event: 'forward' }
        ];

        // ‚úÖ FIX: VR button listener'larƒ±nƒ± track et (cleanup i√ßin)
        panel._buttonListeners = [];

        buttons.forEach(btn => {
            const button = document.createElement('a-text');
            button.setAttribute('value', btn.text);
            button.setAttribute('position', btn.position);
            button.setAttribute('align', 'center');
            button.setAttribute('color', '#4ade80');
            button.setAttribute('width', 4);
            button.setAttribute('class', 'clickable');
            
            const clickHandler = () => handleVRButton(btn.event);
            button.addEventListener('click', clickHandler);
            
            // ‚úÖ FIX: Listener'ƒ± kaydet
            panel._buttonListeners.push({ element: button, handler: clickHandler });
            
            panel.appendChild(button);
        });

        scene.appendChild(panel);
    }
}

        function handleVRButton(action) {
            if (!isRoomOwner) return;
            
            switch(action) {
                case 'play':
                    playVideo();
                    break;
                case 'pause':
                    pauseVideo();
                    break;
                case 'rewind':
                    seekBackward();
                    break;
                case 'forward':
                    seekForward();
                    break;
            }
        }
        
        // ==================== VIDEO CONTROLS (OWNER ONLY) ====================
        let playPromisePending = false;
        
        function playVideo() {
            if (!isRoomOwner || !videoElement) return;
            
            if (syncState && syncState.isBuffering) {
                startSyncCountdown();
                return;
            }
            
            if (playPromisePending) return;
            playPromisePending = true;
            
            lastCommandSource = 'self';
            
            const playPromise = videoElement.play();
            
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    playPromisePending = false;
                    const serverTime = getServerTime();
                    
                    db.ref('rooms/' + currentRoomId + '/videoState').update({
                        isPlaying: true,
                        currentTime: videoElement.currentTime,
                        startTimestamp: serverTime,
                        lastUpdate: firebase.database.ServerValue.TIMESTAMP
                    });
                    
                    // ‚úÖ FIX: Timeout'u track et
                    trackTimeout(setTimeout(() => {
                        lastCommandSource = null;
                    }, 300));
                }).catch(error => {
                    playPromisePending = false;
                    lastCommandSource = null;
                    
                    if (error.name === 'NotAllowedError') {
                        console.warn('Autoplay blocked - user interaction required');
                    } else if (error.name !== 'AbortError') {
                        console.warn('Play error:', error);
                    }
                });
            } else {
                playPromisePending = false;
                const serverTime = getServerTime();
                db.ref('rooms/' + currentRoomId + '/videoState').update({
                    isPlaying: true,
                    currentTime: videoElement.currentTime,
                    startTimestamp: serverTime,
                    lastUpdate: firebase.database.ServerValue.TIMESTAMP
                });
                // ‚úÖ FIX: Timeout'u track et
                trackTimeout(setTimeout(() => { lastCommandSource = null; }, 300));
            }
        }
        
        function pauseVideo() {
            if (!isRoomOwner || !videoElement) return;
            
            if (playPromisePending) {
                const checkAndPause = () => {
                    if (!playPromisePending) {
                        executePause();
                    } else {
                        setTimeout(checkAndPause, 50);
                    }
                };
                setTimeout(checkAndPause, 50);
                return;
            }
            
            executePause();
        }
        
        function executePause() {
            if (!videoElement) return;
            
            lastCommandSource = 'self';
            
            videoElement.pause();
            
            const currentPos = videoElement.currentTime;
            
            const updates = {
                'videoState/isPlaying': false,
                'videoState/currentTime': currentPos,
                'videoState/startTimestamp': getServerTime(),
                'videoState/lastUpdate': firebase.database.ServerValue.TIMESTAMP,
                'keyframes': null,
                'syncState': null
            };
            
            db.ref('rooms/' + currentRoomId).update(updates).then(() => {
                debugLog('‚è∏Ô∏è Pause broadcasted, keyframes/syncState cleared');
            }).catch(err => console.warn('Pause update error:', err));
            
            // ‚úÖ FIX: Timeout'u track et
            trackTimeout(setTimeout(() => {
                lastCommandSource = null;
            }, 300));
        }
        
        // ==================== SYNC MECHANISM ====================
        
        function initiateSync() {
            if (!currentRoomId || !videoElement) return;
            
            debugLog('üîÑ Sync initiated by user');
            
            const syncBtn = getCachedElement('btn-sync');
            if (syncBtn) syncBtn.disabled = true;
            
            db.ref('rooms/' + currentRoomId + '/activeViewers').once('value')
                .then(snapshot => {
                    const viewers = snapshot.val();
                    if (!viewers) return;
                    
                    const positions = [];
                    
                    positions.push(videoElement.currentTime);
                    
                    Object.keys(viewers).forEach(uid => {
                        if (uid !== currentUser.uid && viewers[uid].currentPosition !== undefined) {
                            positions.push(viewers[uid].currentPosition);
                        }
                    });
                    
                    let minPosition = Math.min(...positions);
                    // ‚úÖ FIX: NaN/Infinity validation
                    if (!isFinite(minPosition) || isNaN(minPosition)) {
                        minPosition = videoElement.currentTime || 0;
                    }
                    const targetPosition = Math.max(0, minPosition - 4);
                    
                    debugLog('üìç Positions:', positions, '‚Üí Target:', targetPosition);
                    
                    const currentPos = videoElement.currentTime;
                    if (Math.abs(currentPos - targetPosition) > 1) {
                        db.ref('rooms/' + currentRoomId + '/syncState').set({
                            isBuffering: true,
                            syncedSeekPosition: targetPosition,
                            syncedPlayTime: null,
                            initiatedBy: currentUser.uid,
                            initiatedAt: firebase.database.ServerValue.TIMESTAMP
                        });
                    }
                    
                    applySyncState({
                        isBuffering: true,
                        syncedSeekPosition: targetPosition,
                        syncedPlayTime: null
                    });
                })
                .catch(error => {
                    console.error('Sync error:', error);
                    if (syncBtn) syncBtn.disabled = false;
                });
        }
        
        function applySyncState(state) {
            if (!videoElement || !state) return;
            
            // ‚úÖ FIX: syncedSeekPosition validation
            if (state.syncedSeekPosition !== undefined && state.syncedSeekPosition !== null) {
                if (!isFinite(state.syncedSeekPosition) || isNaN(state.syncedSeekPosition)) {
                    debugLog('‚ö†Ô∏è Invalid syncedSeekPosition in applySyncState');
                    state.syncedSeekPosition = videoElement.currentTime || 0;
                }
            }
            
            syncState = state;
            syncModeActive = true;
            
            if (state.isBuffering) {
                videoElement.pause();
                videoElement.currentTime = state.syncedSeekPosition;
                
                updateSyncUI('üîÑ Senkronizasyon ba≈ülatƒ±ldƒ±...');
                // ‚úÖ FIX: Timeout'larƒ± track et
                trackTimeout(setTimeout(() => {
                    updateSyncUI(`‚è∏Ô∏è Video ${state.syncedSeekPosition.toFixed(1)}s'de duraklatƒ±ldƒ±`);
                }, 500));
                trackTimeout(setTimeout(() => {
                    if (isRoomOwner) {
                        updateSyncUI('‚è≥ Hazƒ±r olduƒüunuzda ‚ñ∂Ô∏è OYNAT butonuna basƒ±n');
                    } else {
                        updateSyncUI('‚è≥ Oda sahibinin oynatmasƒ±nƒ± bekliyoruz...');
                    }
                }, 1000));
                
                updateControlsForSync(true);
                
                // ‚úÖ FIX #9: Buffer timeout 30s ‚Üí 15s
                if (isRoomOwner) {
                    syncTimeoutId = setTimeout(() => {
                        debugLog('‚è∞ Sync timeout - auto starting countdown');
                        startSyncCountdown();
                    }, 15000); // 30s ‚Üí 15s
                }
                
            } else if (state.syncedPlayTime) {
                startSyncCountdownFromState(state);
            }
        }
        
        function startSyncCountdown() {
            if (!isRoomOwner || !syncState) return;
            
            if (syncTimeoutId) {
                clearTimeout(syncTimeoutId);
                syncTimeoutId = null;
            }
            
            const playTime = Date.now() + 5000;
            
            db.ref('rooms/' + currentRoomId + '/syncState').update({
                isBuffering: false,
                syncedPlayTime: playTime
            });
        }
        
        // ‚úÖ FIX #11: Countdown interval'ƒ± track et
        function startSyncCountdownFromState(state) {
            if (!state.syncedPlayTime) return;
            
            const playTime = state.syncedPlayTime;
            const now = Date.now();
            
            if (playTime <= now) {
                // ‚úÖ FIX: Timeout'u track et
                trackTimeout(setTimeout(() => {
                    executeSync(state);
                }, 100));
                return;
            }
            
            // ‚úÖ INTERVAL FIX: DOM element'i d√∂ng√º dƒ±≈üƒ±nda cache'le
            const countdownElement = getCachedElement('sync-countdown');
            if (countdownElement) {
                countdownElement.style.display = 'block';
            }
            
            // ‚úÖ FIX #11: Mevcut interval'ƒ± temizle
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            
            countdownInterval = setInterval(() => {
                const remaining = playTime - Date.now();
                
                if (remaining <= 0) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    
                    // ‚úÖ FIX: Timeout'u track et
                    trackTimeout(setTimeout(() => {
                        executeSync(state);
                    }, 100));
                } else {
                    const seconds = Math.ceil(remaining / 1000);
                    // ‚úÖ countdownElement d√∂ng√º dƒ±≈üƒ±nda cache'lendi
                    if (countdownElement) {
                        countdownElement.textContent = `‚ñ∂Ô∏è ${seconds} saniye sonra ba≈ülƒ±yor...`;
                    }
                    updateSyncUI(`‚è±Ô∏è ${seconds} saniye sonra oynatƒ±lacak...`);
                }
            }, 100);
            
            // ‚úÖ FIX #11: Interval'ƒ± track et
            trackInterval(countdownInterval);
        }
        
        // ‚úÖ FIX #4: executeSync - seek/play yarƒ±≈ümasƒ±nƒ± √∂nle
        function executeSync(state) {
            if (!videoElement || !state) return;
            
            // ‚úÖ FIX: syncedSeekPosition NaN/Infinity validation
            if (!isFinite(state.syncedSeekPosition) || isNaN(state.syncedSeekPosition)) {
                debugLog('‚ö†Ô∏è Invalid syncedSeekPosition, aborting sync');
                clearSyncState();
                return;
            }
            
            debugLog('üé¨ Executing sync at:', Date.now());
            
            // ‚úÖ FIX #4: √ñnce seek, sonra seeked event'i bekle, sonra play
            videoElement.currentTime = state.syncedSeekPosition;
            videoElement.playbackRate = 1.0;
            
            // ‚úÖ FIX: seeked listener'ƒ± track et
            let syncSeekCompleted = false;
            
            const onSeekedForSync = () => {
                if (syncSeekCompleted) return;
                syncSeekCompleted = true;
                videoElement.removeEventListener('seeked', onSeekedForSync);
                
                videoElement.play().then(() => {
                    debugLog('‚úÖ Sync play successful');
                    
                    syncModeActive = false;
                    
                    if (isRoomOwner) {
                        const serverTime = getServerTime();
                        db.ref('rooms/' + currentRoomId + '/videoState').update({
                            isPlaying: true,
                            currentTime: state.syncedSeekPosition,
                            startTimestamp: serverTime,
                            lastUpdate: firebase.database.ServerValue.TIMESTAMP
                        }).then(() => {
                            // ‚úÖ FIX: Timeout'u track et
                            trackTimeout(setTimeout(() => {
                                clearSyncState();
                            }, 500));
                        });
                    } else {
                        // ‚úÖ FIX: Timeout'u track et
                        trackTimeout(setTimeout(() => {
                            clearSyncState();
                        }, 1000));
                    }
                }).catch(error => {
                    console.error('Sync play error:', error);
                    // ‚úÖ FIX: Timeout'u track et
                    trackTimeout(setTimeout(() => {
                        clearSyncState();
                    }, 500));
                });
            };
            
            videoElement.addEventListener('seeked', onSeekedForSync);
            
            // ‚úÖ FIX #4: Timeout fallback - track edildi
            trackTimeout(setTimeout(() => {
                if (!syncSeekCompleted) {
                    syncSeekCompleted = true;
                    videoElement.removeEventListener('seeked', onSeekedForSync);
                    debugLog('‚ö†Ô∏è Sync seeked timeout, forcing play');
                    videoElement.play().catch(() => {});
                    syncModeActive = false;
                    clearSyncState();
                }
            }, 3000));
        }
        
        function clearSyncState() {
            syncState = null;
            syncModeActive = false;
            
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            
            if (syncTimeoutId) {
                clearTimeout(syncTimeoutId);
                syncTimeoutId = null;
            }
            
            const countdownElement = getCachedElement('sync-countdown');
            if (countdownElement) {
                countdownElement.style.display = 'none';
                countdownElement.textContent = '';
            }
            
            updateControlsForSync(false);
            
            if (isRoomOwner && currentRoomId) {
                db.ref('rooms/' + currentRoomId + '/syncState').remove();
            }
            
            debugLog('üßπ Sync state cleared');
        }
        
        function updateSyncUI(message) {
            const statusText = getCachedElement('sync-text');
            if (statusText) {
                statusText.textContent = message;
                statusText.className = 'status-warning';
            }
        }
        
        function updateControlsForSync(inSync) {
            const playBtn = getCachedElement('btn-play');
            const pauseBtn = getCachedElement('btn-pause');
            const rewindBtn = getCachedElement('btn-rewind');
            const forwardBtn = getCachedElement('btn-forward');
            const syncBtn = getCachedElement('btn-sync');
            
            if (inSync) {
                if (pauseBtn) pauseBtn.disabled = true;
                if (rewindBtn) rewindBtn.disabled = true;
                if (forwardBtn) forwardBtn.disabled = true;
                if (syncBtn) syncBtn.disabled = true;
                
                if (playBtn) {
                    playBtn.disabled = !isRoomOwner;
                }
            } else {
                if (isRoomOwner) {
                    if (playBtn) playBtn.disabled = false;
                    if (pauseBtn) pauseBtn.disabled = false;
                    if (rewindBtn) rewindBtn.disabled = false;
                    if (forwardBtn) forwardBtn.disabled = false;
                }
                if (syncBtn) syncBtn.disabled = false;
            }
        }
        
        function listenSyncState() {
            const ref = db.ref('rooms/' + currentRoomId + '/syncState');
            trackListener(ref);
            
            ref.on('value', (snapshot) => {
                const state = snapshot.val();
                
                if (state) {
                    applySyncState(state);
                } else {
                    if (syncState) {
                        clearSyncState();
                    }
                }
            });
        }
        
        function updateViewerPosition() {
            if (!currentUser || !currentRoomId || !videoElement) return;
            
            try {
                db.ref('rooms/' + currentRoomId + '/activeViewers/' + currentUser.uid + '/currentPosition')
                    .set(videoElement.currentTime)
                    .catch(() => {});
            } catch (error) {
                console.warn('Position update error:', error);
            }
        }
        
        // ‚úÖ FIX #10: syncVideoState - recursive trigger √∂nleme
        let isSyncingVideoState = false;
        
        

function syncVideoState() {
    if (!isRoomOwner || !videoElement) return;

    if (isSyncingVideoState) {
        debugLog('‚ö†Ô∏è syncVideoState already in progress, skipping');
        return;
    }

    isSyncingVideoState = true;
    const serverTime = getServerTime();

    db.ref(`rooms/${currentRoomId}/videoState`).update({
        isPlaying: !videoElement.paused,
        currentTime: videoElement.currentTime,
        startTimestamp: serverTime,
        lastUpdate: firebase.database.ServerValue.TIMESTAMP
    })
    .then(() => {
        isSyncingVideoState = false;
    })
    .catch((err) => {
        console.warn('Sync update error:', err);
        isSyncingVideoState = false;
    });
}

        // ==================== VIDEO SYNC (OPTIMIZED) ====================
        let lastVideoStateUpdate = 0;
        let previousVideoState = null;
        
        // ‚úÖ FIX #5 & #6: syncVideo - main thread blokajƒ± ve DOM thrashing azaltma
        function syncVideo() {
            // ‚úÖ FIX: isHardSeeking kontrol√º eklendi
            if (isRoomOwner || isSeeking || isHardSeeking) return;
            if (!videoElement || !currentRoomData || !currentRoomData.videoState) return;

            if (syncState && syncState.isBuffering) return;

            const state = currentRoomData.videoState;
            const serverTime = getServerTime();
            let expectedTime = state.currentTime; 

            if (state.isPlaying) {
                const elapsed = (serverTime - state.startTimestamp) / 1000;
                // ‚úÖ FIX: elapsed NaN/Infinity validation (max 24 saat)
                if (!isFinite(elapsed) || elapsed < 0 || elapsed > 86400) {
                    debugLog('‚ö†Ô∏è Invalid elapsed time, skipping sync');
                    return;
                }
                expectedTime = state.currentTime + elapsed;
            }

            const duration = videoElement.duration || Infinity;
            expectedTime = Math.max(0, Math.min(duration, expectedTime));

            const currentTime = videoElement.currentTime;
            const drift = Math.abs(currentTime - expectedTime) * 1000;

            debugLog(`Sync - Expected: ${expectedTime}, Current: ${currentTime}, Drift: ${drift}, Playing: ${state.isPlaying}`);

            if (!state.isPlaying) {
                if (!videoElement.paused) {
                    videoElement.pause();
                }
                videoElement.playbackRate = 1.0;

                // ‚úÖ FIX #6: isBuffering flag'i pause'da temizle
                if (isBuffering) {
                    if (bufferCountdownInterval) {
                        clearInterval(bufferCountdownInterval);
                        bufferCountdownInterval = null;
                    }
                    isBuffering = false;
                    const bufferEl = getCachedElement('buffer-countdown');
                    if (bufferEl) bufferEl.style.display = 'none';
                    debugLog('isBuffering cleared due to pause');
                }

                if (drift > 500) {
                    const alreadyAtPosition = Math.abs(videoElement.currentTime - expectedTime) < 0.5;
                    if (!alreadyAtPosition) {
                        debugLog(`Paused - seeking to owner position, ${expectedTime}`);
                        videoElement.currentTime = expectedTime;
                    }
                }
                return;
            }

            // PLAYING STATE SYNC
            if (drift <= TIER1_THRESHOLD) {
                if (videoElement.paused) {
                    videoElement.play().catch(err => console.warn('Play failed:', err));
                    // ‚úÖ FIX: Timeout'u track et
                    trackTimeout(setTimeout(() => videoElement.play().catch(() => {}), 200));
                }
                videoElement.playbackRate = 1.0;
            } else if (drift <= TIER2_THRESHOLD) {
                if (videoElement.paused) {
                    videoElement.play().catch(() => {});
                }
                const behind = currentTime < expectedTime;
                videoElement.playbackRate = behind ? TIER2_LAGGING_SPEED : 0.95;
            } else if (drift <= TIER3_THRESHOLD) {
                if (videoElement.paused) {
                    videoElement.play().catch(() => {});
                }
                const behind = currentTime < expectedTime;
                videoElement.playbackRate = behind ? TIER3_LAGGING_SPEED : 0.90;
            } else if (drift <= 3000) {
                // 1.5-3 saniye arasƒ± drift
                if (videoElement.paused) {
                    videoElement.play().catch(() => {});
                }
                const behind = currentTime < expectedTime;
                videoElement.playbackRate = behind ? 1.25 : 0.85;
            } else if (drift <= LARGE_DRIFT_THRESHOLD) {
                // 3-9 saniye arasƒ± drift - daha agresif playbackRate
                if (videoElement.paused) {
                    videoElement.play().catch(() => {});
                }
                const behind = currentTime < expectedTime;
                videoElement.playbackRate = behind ? 1.5 : 0.75;
            } else {
                // Large drift (9+ seconds) - Hard seek with throttle
                const now = Date.now();
                if (now - lastHardSeekTime < HARD_SEEK_MIN_INTERVAL || isHardSeeking) {
                    debugLog(`Hard seek throttled or in progress, using playbackRate`);
                    if (videoElement.paused) {
                        videoElement.play().catch(() => {});
                    }
                    const behind = currentTime < expectedTime;
                    videoElement.playbackRate = behind ? 1.75 : 0.65; // ‚úÖ FIX: Daha agresif
                    return;
                }

                debugLog(`Large drift detected, ${drift}ms - initiating buffer-wait`);
                isBuffering = true;
                isHardSeeking = true; // ‚úÖ FIX: Hard seek ba≈ülƒ±yor
                lastHardSeekTime = now;

                const BUFFER_ADVANCE = 9; // ‚úÖ FIX: 7 -> 9 saniye
                const targetSeek = expectedTime - BUFFER_ADVANCE;
                const clampedTarget = Math.max(0, Math.min(duration, targetSeek));

                videoElement.pause();
                
                // ‚úÖ FIX: seeked event ile isHardSeeking'i temizle
                const onHardSeeked = () => {
                    videoElement.removeEventListener('seeked', onHardSeeked);
                    isHardSeeking = false;
                    debugLog('‚úÖ Hard seek completed (syncVideo)');
                };
                videoElement.addEventListener('seeked', onHardSeeked);
                
                videoElement.currentTime = clampedTarget;
                lastSyncedPosition = clampedTarget;
                bufferTargetTime = Date.now() + (BUFFER_ADVANCE * 1000);
                
                // ‚úÖ FIX: Timeout fallback - seeked event gelmezse temizle - TRACKED
                trackTimeout(setTimeout(() => {
                    if (isHardSeeking) {
                        videoElement.removeEventListener('seeked', onHardSeeked);
                        isHardSeeking = false;
                        debugLog('‚ö†Ô∏è Hard seek timeout (syncVideo)');
                    }
                }, 3000));

                // ‚úÖ INTERVAL FIX: DOM element'i d√∂ng√º dƒ±≈üƒ±nda cache'le
                const countdownEl = getCachedElement('buffer-countdown');
                if (countdownEl) countdownEl.style.display = 'block';

                // ‚úÖ FIX #11: Mevcut interval'ƒ± temizle
                if (bufferCountdownInterval) {
                    clearInterval(bufferCountdownInterval);
                    bufferCountdownInterval = null;
                }

                bufferCountdownInterval = setInterval(() => {
                    const remaining = Math.max(0, bufferTargetTime - Date.now());
                    const seconds = Math.ceil(remaining / 1000);

                    // ‚úÖ countdownEl d√∂ng√º dƒ±≈üƒ±nda cache'lendi
                    if (countdownEl) {
                        countdownEl.textContent = `${seconds}s`;
                    }

                    if (remaining <= 0) {
                        clearInterval(bufferCountdownInterval);
                        bufferCountdownInterval = null;
                        isBuffering = false;

                        if (countdownEl) countdownEl.style.display = 'none';

                        if (currentRoomData.videoState && currentRoomData.videoState.isPlaying) {
                            videoElement.play().catch(() => {});
                            videoElement.playbackRate = 1.0;
                            debugLog(`Buffer complete - auto-started`);
                        }
                    }
                }, 100);
            }
        }


        function listenVideoState() {
            const ref = db.ref(`rooms/${currentRoomId}/videoState`);
            trackListener(ref);

            ref.on('value', snapshot => {
                const newState = snapshot.val();
                if (!newState) return;

                if (syncModeActive) {
                    debugLog('Ignoring video state update - sync mode active');
                    return;
                }

                if (lastCommandSource === 'self') {
                    debugLog('Ignoring self-triggered video state update');
                    return;
                }

                const oldState = previousVideoState;

                if (oldState &&
                    oldState.isPlaying === newState.isPlaying &&
                    Math.abs(oldState.currentTime - newState.currentTime) < 0.1 &&
                    oldState.startTimestamp === newState.startTimestamp) {
                    return;
                }

                // ‚úÖ FIX: JSON.parse/stringify yerine shallow copy (daha hƒ±zlƒ±)
                previousVideoState = {
                    isPlaying: newState.isPlaying,
                    currentTime: newState.currentTime,
                    startTimestamp: newState.startTimestamp,
                    lastUpdate: newState.lastUpdate
                };
                currentRoomData.videoState = newState;

                if (!isRoomOwner) {
                    const now = Date.now();

                    if (oldState && oldState.isPlaying && !newState.isPlaying) {
                        debugLog('Pause command detected - syncing immediately (bypass throttle)');
                        lastVideoStateUpdate = now;
                        syncVideo();
                        return;
                    }

                    if (now - lastVideoStateUpdate < SYNCCHECKINTERVAL) return;

                    lastVideoStateUpdate = now;
                    syncVideo();
                }
            });
        }


        function sendKeyframe() {
            // ‚úÖ FIX: isHardSeeking kontrol√º eklendi
            if (!videoElement || !isRoomOwner || isSeeking || isHardSeeking) return;

            try {
                const ref = db.ref('rooms/' + currentRoomId + '/keyframes').push({
                    time: videoElement.currentTime,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });

                trackTimeout(setTimeout(() => ref.remove().catch(() => {}), 30000));
            } catch (error) {
                console.warn('Keyframe send error:', error);
            }
        }

        
        function listenKeyframes() {
            const ref = db.ref('rooms/' + currentRoomId + '/keyframes').limitToLast(1);
            trackListener(ref);

            ref.on('child_added', snapshot => {
                const keyframe = snapshot.val();
                if (!videoElement) return;

                // ‚úÖ FIX: isHardSeeking kontrol√º eklendi
                if (syncState || isBuffering || isSeeking || isHardSeeking) return;

                const drift = Math.abs(videoElement.currentTime - keyframe.time) * 1000;

                if (drift > LARGE_DRIFT_THRESHOLD) {
                    if (isSeeking || isHardSeeking) return; // ‚úÖ FIX: √áift kontrol

                    const now = Date.now();
                    if (now - lastHardSeekTime > HARD_SEEK_MIN_INTERVAL) {
                        isHardSeeking = true; // ‚úÖ FIX: Hard seek ba≈ülƒ±yor
                        lastHardSeekTime = now;
                        
                        // ‚úÖ FIX: seeked event ile isHardSeeking'i temizle
                        const onKeyframeSeeked = () => {
                            videoElement.removeEventListener('seeked', onKeyframeSeeked);
                            isHardSeeking = false;
                            debugLog('‚úÖ Keyframe seek completed');
                        };
                        videoElement.addEventListener('seeked', onKeyframeSeeked);
                        
                        videoElement.currentTime = keyframe.time;
                        lastSyncedPosition = keyframe.time;
                        debugLog('üîÅ Keyframe sync', keyframe.time);
                        
                        // ‚úÖ FIX: Timeout fallback - TRACKED
                        trackTimeout(setTimeout(() => {
                            if (isHardSeeking) {
                                videoElement.removeEventListener('seeked', onKeyframeSeeked);
                                isHardSeeking = false;
                                debugLog('‚ö†Ô∏è Keyframe seek timeout');
                            }
                        }, 3000));
                    }
                }
            });
        }

        
        function trackDrift() {
            // ‚úÖ FIX: isHardSeeking kontrol√º eklendi
            if (!videoElement || !currentRoomData || !currentRoomData.videoState || isSeeking || isHardSeeking) return;

            try {
                const state = currentRoomData.videoState;
                const serverTime = getServerTime();
                const expectedTime = state.isPlaying 
                    ? state.currentTime + (serverTime - state.startTimestamp) / 1000 
                    : state.currentTime;

                const drift = (videoElement.currentTime - expectedTime) * 1000;

                if (lastDriftValue === null || Math.abs(drift - lastDriftValue) > 1000) {
                    if (shouldUpdateFirebase()) {
                        queueFirebaseUpdate('activeViewers/' + currentUser.uid + '/currentDrift', drift);
                    }
                    lastDriftValue = drift;
                }
            } catch (error) {
                console.warn('Drift tracking error:', error);
            }
        }

        
        function updatePresence() {
            if (!currentUser || !currentRoomId) return;
            
            try {
                queueFirebaseUpdate(
                    'activeViewers/' + currentUser.uid + '/lastSeen',
                    firebase.database.ServerValue.TIMESTAMP
                );
            } catch (error) {
                console.warn('Presence update error:', error);
            }
        }
        
        function checkOwnerPresence() {
            if (!isRoomOwner && currentRoomData && currentUser) {
                db.ref('rooms/' + currentRoomId + '/activeViewers/' + currentRoomData.owner).once('value')
                    .then(snapshot => {
                        const ownerData = snapshot.val();
                        if (!ownerData || (Date.now() - ownerData.lastSeen > OWNER_PRESENCE_TIMEOUT)) {
                            db.ref('rooms/' + currentRoomId + '/activeViewers').once('value')
                                .then(viewersSnapshot => {
                                    const viewers = viewersSnapshot.val();
                                    if (viewers) {
                                        const newOwner = Object.keys(viewers)[0];
                                        if (newOwner === currentUser.uid) {
                                            db.ref('rooms/' + currentRoomId).update({ owner: newOwner });
                                            isRoomOwner = true;
                                            debugLog('üëë Ownership transferred to you');
                                        }
                                    }
                                });
                        }
                    })
                    .catch(() => {});
            }
        }
        
        // ==================== UI UPDATES (DEBOUNCED) ====================
        function updateRoomInfoDisplay() {
            if (!currentRoomData) return;
            getCachedElement('room-name-display').textContent = currentRoomData.name + (isRoomOwner ? ' üëë' : '');
            updateViewerCount();
        }
        
        // ‚úÖ FIX #12: DOM thrashing azaltma - queueRAF kullan
        function updateViewerCount() {
            if (!currentRoomId || !shouldUpdateUI()) return;
            
            db.ref('rooms/' + currentRoomId + '/activeViewers').once('value')
                .then(snapshot => {
                    const count = snapshot.numChildren();
                    queueRAF(() => {
                        const viewerElement = getCachedElement('viewer-count');
                        if (viewerElement) {
                            viewerElement.textContent = `üë• ${count} izleyici`;
                        }
                    });
                })
                .catch(() => {});
        }
        
        function cleanupOldData() {
            if (!currentRoomId || !isRoomOwner) return;
            
            try {
                const cutoffTime = Date.now() - 60000;
                
                db.ref('rooms/' + currentRoomId + '/keyframes').once('value')
                    .then(snapshot => {
                        if (snapshot.exists()) {
                            snapshot.forEach(child => {
                                const data = child.val();
                                if (data.timestamp && data.timestamp < cutoffTime) {
                                    child.ref.remove().catch(() => {});
                                }
                            });
                        }
                    })
                    .catch(() => {});
                
                db.ref('rooms/' + currentRoomId + '/activeViewers').once('value')
                    .then(snapshot => {
                        if (snapshot.exists()) {
                            snapshot.forEach(child => {
                                const viewer = child.val();
                                if (viewer.lastSeen && (Date.now() - viewer.lastSeen > 60000)) {
                                    child.ref.remove().catch(() => {});
                                }
                            });
                        }
                    })
                    .catch(() => {});
                
                debugLog('üßπ Cleanup old data');
            } catch (error) {
                console.warn('Cleanup error:', error);
            }
        }
        
        // ‚úÖ FIX #12: updateSyncStatus - queueRAF ile DOM thrashing √∂nle
        function updateSyncStatus(drift) {
            if (!shouldUpdateUI()) return;
            
            queueRAF(() => {
                const statusText = getCachedElement('sync-text');
                if (!statusText) return;
                
                if (drift < TIER1_THRESHOLD) {
                    statusText.textContent = '‚úÖ Senkronize';
                    statusText.className = 'status-good';
                } else if (drift < TIER2_THRESHOLD) {
                    statusText.textContent = '‚ö†Ô∏è Hafif sapma';
                    statusText.className = 'status-warning';
                } else {
                    statusText.textContent = '‚ùå Senkronizasyon kaybƒ±';
                    statusText.className = 'status-error';
                }
            });
        }
        
        // ==================== PERIODIC TASKS ====================
        function startPeriodicTasks() {
            trackInterval(setInterval(initClockSync, CLOCK_SYNC_INTERVAL));
            trackInterval(setInterval(trackDrift, DRIFT_UPDATE_INTERVAL));
            trackInterval(setInterval(updatePresence, PRESENCE_UPDATE_INTERVAL));
            trackInterval(setInterval(updateViewerCount, 10000));
            trackInterval(setInterval(updateViewerPosition, 5000));
            
            if (!isRoomOwner) {
                trackInterval(setInterval(checkOwnerPresence, 30000));
            }
            
            debugLog('‚úÖ Periodic tasks started');
        }
        
        // ‚úÖ FIX: Owner interval ID'lerini ayrƒ± track et (birikim √∂nleme)
        let ownerKeyframeInterval = null;
        let ownerCleanupInterval = null;
        
        function clearOwnerTasks() {
            if (ownerKeyframeInterval) {
                clearInterval(ownerKeyframeInterval);
                ownerKeyframeInterval = null;
            }
            if (ownerCleanupInterval) {
                clearInterval(ownerCleanupInterval);
                ownerCleanupInterval = null;
            }
            debugLog('üßπ Owner tasks cleared');
        }
        
        function startOwnerTasks() {
            // ‚úÖ FIX: √ñnce mevcut owner interval'larƒ±nƒ± temizle (birikim √∂nleme)
            clearOwnerTasks();
            
            ownerKeyframeInterval = setInterval(sendKeyframe, KEYFRAME_INTERVAL);
            ownerCleanupInterval = setInterval(cleanupOldData, 30000);
            
            trackInterval(ownerKeyframeInterval);
            trackInterval(ownerCleanupInterval);
            
            debugLog('üëë Owner tasks started');
        }
        

// DOMContentLoaded'dan √ñNCE, script i√ßinde ekle:
// ‚úÖ FIX: video-texture-fix artƒ±k throttled - her frame yerine 100ms'de bir
AFRAME.registerComponent('video-texture-fix', {
    schema: { type: 'selector' },
    init: function () {
        this.videoEl = this.data;
        this.material = null;
        this.lastUpdate = 0;
        this.updateInterval = 100; // ms - 10 FPS yeterli texture update i√ßin
    },
    tick: function (time) {
        if (!this.videoEl) return;
        
        // Throttle: sadece 100ms'de bir g√ºncelle
        if (time - this.lastUpdate < this.updateInterval) return;
        this.lastUpdate = time;
        
        // readyState >= 2 means HAVE_CURRENT_DATA or higher
        // Sadece video oynatƒ±lƒ±yorken g√ºncelle
        if (this.videoEl.readyState >= 2 && !this.videoEl.paused) {
            if (!this.material) {
                const mesh = this.el.getObject3D('mesh');
                if (mesh && mesh.material) {
                    this.material = mesh.material;
                }
            }
            
            if (this.material && this.material.map) {
                this.material.map.needsUpdate = true;
            }
        }
    }
});


        // ==================== INIT ====================
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üé¨ VR Cinema ULTRA - Optimized v3.6 (Memory Leak Fixes)');
            updateQualityCapUI();
            
            const scene = document.querySelector('a-scene');
            if (scene) {
                // ‚úÖ FIX: Listener'larƒ± referansla kaydet (cleanup i√ßin)
                sceneEnterVRHandler = () => {
                    const cursor = getCachedElement('vr-cursor');
                    if (cursor) {
                        cursor.setAttribute('visible', 'true');
                        debugLog('üëì VR mode: Raycaster enabled');
                    }
                };
                
                sceneExitVRHandler = () => {
                    const cursor = getCachedElement('vr-cursor');
                    if (cursor) {
                        cursor.setAttribute('visible', 'false');
                        debugLog('üëì VR mode exit: Raycaster disabled');
                    }
                };
                
                scene.addEventListener('enter-vr', sceneEnterVRHandler);
                scene.addEventListener('exit-vr', sceneExitVRHandler);
            }
            
            // ‚úÖ FIX: Keyboard listener'ƒ± referansla kaydet (cleanup i√ßin)
            keydownHandler = (e) => {
                if (!currentRoomId || !isRoomOwner) return;
                
                switch(e.key) {
                    case ' ':
                        e.preventDefault();
                        if (videoElement && videoElement.paused) {
                            playVideo();
                        } else {
                            pauseVideo();
                        }
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        seekBackward();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        seekForward();
                        break;
                }
            };
            
            document.addEventListener('keydown', keydownHandler);
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            fullCleanup();
        });
    </script>
</body> 
</html>