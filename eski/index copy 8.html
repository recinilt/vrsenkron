<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Sinema ULTRA - Optimized</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    
    <!-- A-Frame VR -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow-x: hidden;
        }
        
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.95);
            transition: opacity 0.3s;
        }
        
        #ui-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .container {
            max-width: 600px;
            width: 90%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 16px;
        }
        
        textarea {
            min-height: 80px;
            resize: vertical;
        }
        
        button {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        #room-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }
        
        .room-item {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .room-item:hover {
            background: rgba(255, 255, 255, 0.25);
        }
        
        .room-name {
            font-weight: 600;
            font-size: 18px;
            margin-bottom: 5px;
        }
        
        .room-details {
            font-size: 14px;
            opacity: 0.8;
        }
        
        #vr-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 500;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            display: none;
            gap: 10px;
            align-items: center;
        }
        
        #vr-controls button {
            width: auto;
            padding: 10px 20px;
            margin: 0 5px;
            font-size: 14px;
        }
        
        #room-info {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 500;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            display: none;
            max-width: 300px;
        }
        
        #sync-status {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 500;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 10px 15px;
            border-radius: 10px;
            display: none;
            font-size: 14px;
        }
        
        .status-good { color: #4ade80; }
        .status-warning { color: #fbbf24; }
        .status-error { color: #f87171; }
        
        #viewer-count {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        a-scene {
            width: 100%;
            height: 100vh;
        }
        
        .hidden {
            display: none !important;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }
            h1 {
                font-size: 2em;
            }
            #vr-controls {
                bottom: 10px;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- UI Overlay -->
    <div id="ui-overlay">
        <div class="container">
            <h1>üé¨ VR Sinema ULTRA</h1>
            
            <div id="create-room-section">
                <div class="input-group">
                    <label>Oda Adƒ±</label>
                    <input type="text" id="room-name" placeholder="√ñzel film gecesi">
                </div>
                
                <div class="input-group">
                    <label>Video URL</label>
                    <input type="text" id="video-url" placeholder="YouTube, Google Drive veya direkt video linki">
                </div>
                
                <div class="input-group">
                    <label>A√ßƒ±klama (isteƒüe baƒülƒ±)</label>
                    <textarea id="room-description" placeholder="Bu odada ne izlenecek?"></textarea>
                </div>
                
                <div class="input-group">
                    <label>Ekran Boyutu</label>
                    <select id="screen-size">
                        <option value="medium">Orta (16:9)</option>
                        <option value="large">B√ºy√ºk (21:9)</option>
                        <option value="imax">IMAX (1.43:1)</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label>Ortam</label>
                    <select id="environment">
                        <option value="none">Yok (En Hƒ±zlƒ±)</option>
                        <option value="minimal">Minimal</option>
                    </select>
                </div>
                
                <button onclick="createRoom()">üöÄ Oda Olu≈ütur ve Katƒ±l</button>
                <button onclick="showRoomList()">üìã Mevcut Odalar</button>
            </div>
            
            <div id="room-list-section" class="hidden">
                <button onclick="showCreateRoom()">‚Üê Geri</button>
                <div id="room-list"></div>
            </div>
        </div>
    </div>
    
    <!-- VR Controls (2D overlay) -->
    <div id="vr-controls">
        <button id="btn-play" onclick="playVideo()">‚ñ∂Ô∏è Oynat</button>
        <button id="btn-pause" onclick="pauseVideo()">‚è∏Ô∏è Duraklat</button>
        <button id="btn-rewind" onclick="seekBackward()">‚è™ -10s</button>
        <button id="btn-forward" onclick="seekForward()">‚è© +10s</button>
        <button id="btn-sync" onclick="initiateSync()">üîÑ Sync</button>
        <button onclick="leaveRoom()">üö™ √áƒ±k</button>
    </div>
    
    <!-- Room Info -->
    <div id="room-info">
        <div id="room-name-display"></div>
        <div id="viewer-count"></div>
    </div>
    
    <!-- Sync Status -->
    <div id="sync-status">
        <span id="sync-text">Senkronize</span>
        <div id="sync-countdown" style="display: none; margin-top: 5px; font-size: 18px; font-weight: bold;"></div>
    </div>
    
    <!-- A-Frame Scene -->
    <a-scene vr-mode-ui="enabled: true" loading-screen="enabled: false">
        <a-assets></a-assets>
        
        <!-- Camera with cursor for VR interaction (optimized) -->
        <a-camera position="0 1.6 0">
            <a-cursor
                id="vr-cursor"
                color="#4ade80"
                raycaster="objects: .clickable; interval: 1000; far: 5"
                fuse="false"
                visible="false">
            </a-cursor>
        </a-camera>
        
        <!-- Lighting (minimal for performance) -->
        <a-light type="ambient" color="#BBB" intensity="0.5"></a-light>
    </a-scene>
    
    <script>
        // ==================== CONFIG ====================
        const firebaseConfig = {
            apiKey: "AIzaSyC60idSLdAiqAjPWAOMaM3g8LAKPGEUwH8",
            authDomain: "vr-sinema.firebaseapp.com",
            databaseURL: "https://vr-sinema-default-rtdb.firebaseio.com",
            projectId: "vr-sinema",
            storageBucket: "vr-sinema.firebasestorage.app",
            messagingSenderId: "724648238300",
            appId: "1:724648238300:web:dceba8c536e8a5ffd96819"
        };
        
        // ==================== OPTIMIZED CONSTANTS ====================
        const SYNC_CHECK_INTERVAL = 500;           // 200ms ‚Üí 500ms (daha az CPU)
        const KEYFRAME_INTERVAL = 10000;            // 7s ‚Üí 10s 
        const CLOCK_SYNC_INTERVAL = 60000;          // 60s (deƒüi≈ümedi)
        const DRIFT_UPDATE_INTERVAL = 5000;         // 5s (√ßok daha az Firebase yazma)
        const PRESENCE_UPDATE_INTERVAL = 30000;     // 5s ‚Üí 30s (Firebase y√ºk√ºn√º azalt)
        const CLEANUP_INTERVAL = 10000;             // 10s d√ºzenli temizlik
        const PLAY_BUFFER_TIME = 5000;              
        const PRELOAD_BUFFER_SECONDS = 7;
        
        // Optimized thresholds (daha toleranslƒ±)
        const TIER1_THRESHOLD = 300;                // 100ms ‚Üí 300ms
        const TIER2_THRESHOLD = 800;                // 500ms ‚Üí 800ms  
        const TIER3_THRESHOLD = 1500;               // 1000ms ‚Üí 1500ms
        const TIER2_LAGGING_SPEED = 1.05;           // 1.1 ‚Üí 1.05 (yumu≈üak)
        const TIER3_LAGGING_SPEED = 1.15;           // 1.25 ‚Üí 1.15 (yumu≈üak)
        
        const OWNER_PRESENCE_UPDATE_INTERVAL = 30000;  // 5s ‚Üí 30s
        const OWNER_PRESENCE_TIMEOUT = 45000;          // 15s ‚Üí 45s
        const DEBUG_MODE = false;
        
        // ==================== GLOBAL STATE ====================
        let db, auth, currentUser, currentRoomId, currentRoomData;
        let videoElement, isRoomOwner = false;
        let clockOffset = 0;
        
        // Interval tracking for cleanup (Memory Leak Prevention)
        const activeIntervals = [];
        const activeTimeouts = [];
        const firebaseListeners = [];
        
        // Performance optimization
        let lastDriftValue = null;
        let lastFirebaseUpdate = 0;
        let lastUIUpdate = 0;
        
        
        // Sync mechanism
        let syncState = null;
        let countdownInterval = null;
        let syncTimeoutId = null;
        let lastSyncCheck = 0;
        
        // Cached DOM elements
        let cachedElements = {};
        
        // Firebase batch updates
        let pendingFirebaseUpdates = {};
        let firebaseBatchTimeout = null;
        
        // ==================== FIREBASE INIT ====================
        firebase.initializeApp(firebaseConfig);
        db = firebase.database();
        auth = firebase.auth();
        
        // ==================== HELPER FUNCTIONS ====================
        function debugLog(...args) {
            if (DEBUG_MODE) console.log(...args);
        }
        
        function getServerTime() {
            return Date.now() + clockOffset;
        }
        
        // DOM Element Caching
        function getCachedElement(id) {
            if (!cachedElements[id]) {
                cachedElements[id] = document.getElementById(id);
            }
            return cachedElements[id];
        }
        
        function clearElementCache() {
            cachedElements = {};
        }
        
        // ==================== MEMORY LEAK PREVENTION ====================
        function trackInterval(id) {
            if (id) activeIntervals.push(id);
            return id;
        }
        
        function trackTimeout(id) {
            if (id) activeTimeouts.push(id);
            return id;
        }
        
        function trackListener(ref) {
            if (ref) firebaseListeners.push(ref);
            return ref;
        }
        
        function clearAllIntervals() {
            activeIntervals.forEach(id => clearInterval(id));
            activeIntervals.length = 0;
        }
        
        function clearAllTimeouts() {
            activeTimeouts.forEach(id => clearTimeout(id));
            activeTimeouts.length = 0;
        }
        
        function clearAllListeners() {
            firebaseListeners.forEach(ref => {
                try {
                    ref.off();
                } catch (e) {
                    console.warn('Listener cleanup error:', e);
                }
            });
            firebaseListeners.length = 0;
        }
        
        function fullCleanup() {
            clearAllIntervals();
            clearAllTimeouts();
            clearAllListeners();
            clearElementCache();
            
            // Clear Firebase batch
            if (firebaseBatchTimeout) {
                clearTimeout(firebaseBatchTimeout);
                firebaseBatchTimeout = null;
            }
            pendingFirebaseUpdates = {};
            
            debugLog('üßπ Full cleanup completed');
        }
        
        // ==================== FIREBASE BATCH UPDATES ====================
        function queueFirebaseUpdate(path, value) {
            pendingFirebaseUpdates[path] = value;
            
            if (!firebaseBatchTimeout) {
                firebaseBatchTimeout = setTimeout(() => {
                    if (Object.keys(pendingFirebaseUpdates).length > 0 && currentRoomId) {
                        db.ref('rooms/' + currentRoomId)
                            .update(pendingFirebaseUpdates)
                            .catch(err => console.warn('Batch update error:', err));
                        
                        pendingFirebaseUpdates = {};
                    }
                    firebaseBatchTimeout = null;
                }, 1000);
            }
        }
        
        function shouldUpdateFirebase() {
            const now = Date.now();
            if (now - lastFirebaseUpdate < 5000) { // 3s ‚Üí 5s
                return false;
            }
            lastFirebaseUpdate = now;
            return true;
        }
        
        function shouldUpdateUI() {
            const now = Date.now();
            if (now - lastUIUpdate < 300) { // UI debounce 300ms
                return false;
            }
            lastUIUpdate = now;
            return true;
        }
        
        // ==================== CLOCK SYNC ====================
        async function initClockSync() {
            try {
                const samples = [];
                for (let i = 0; i < 3; i++) {
                    const t0 = Date.now();
                    const ref = db.ref('.info/serverTimeOffset');
                    const snapshot = await ref.once('value');
                    const offset = snapshot.val();
                    const t1 = Date.now();
                    const rtt = t1 - t0;
                    const serverTime = Date.now() + offset;
                    const calculatedOffset = serverTime - (t0 + rtt / 2);
                    samples.push(calculatedOffset);
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                clockOffset = samples.reduce((a, b) => a + b, 0) / samples.length;
                debugLog('üïê Clock offset:', clockOffset, 'ms');
            } catch (error) {
                console.warn('Clock sync error:', error);
            }
        }
        
        // ==================== ROOM MANAGEMENT ====================
        async function createRoom() {
            const roomName = getCachedElement('room-name').value.trim();
            const videoUrl = getCachedElement('video-url').value.trim();
            const screenSize = getCachedElement('screen-size').value;
            const environment = getCachedElement('environment').value;
            
            if (!roomName || !videoUrl) {
                alert('L√ºtfen oda adƒ± ve video URL giriniz!');
                return;
            }
            
            try {
                const userCredential = await auth.signInAnonymously();
                currentUser = userCredential.user;
                
                const roomRef = db.ref('rooms').push();
                currentRoomId = roomRef.key;
                
                await roomRef.set({
                    name: roomName,
                    owner: currentUser.uid,
                    videoUrl: videoUrl,
                    screenSize: screenSize,
                    environment: environment,
                    createdAt: firebase.database.ServerValue.TIMESTAMP,
                    videoState: {
                        isPlaying: false,
                        currentTime: 0,
                        startTimestamp: 0,
                        lastUpdate: firebase.database.ServerValue.TIMESTAMP
                    }
                });
                
                await joinRoom(currentRoomId);
            } catch (error) {
                console.error('‚ùå Oda olu≈üturma hatasƒ±:', error);
                alert('Oda olu≈üturulamadƒ±: ' + error.message);
            }
        }
        
        async function joinRoom(roomId) {
            try {
                if (!auth.currentUser) {
                    const userCredential = await auth.signInAnonymously();
                    currentUser = userCredential.user;
                } else {
                    currentUser = auth.currentUser;
                }
                
                currentRoomId = roomId;
                const roomSnapshot = await db.ref('rooms/' + roomId).once('value');
                currentRoomData = roomSnapshot.val();
                
                if (!currentRoomData) {
                    alert('Oda bulunamadƒ±!');
                    return;
                }
                
                isRoomOwner = currentUser.uid === currentRoomData.owner;
                
                // Add to active viewers
                const viewerRef = db.ref('rooms/' + roomId + '/activeViewers/' + currentUser.uid);
                await viewerRef.set({
                    joinedAt: firebase.database.ServerValue.TIMESTAMP,
                    lastSeen: firebase.database.ServerValue.TIMESTAMP,
                    isOwner: isRoomOwner,
                    currentDrift: 0
                });
                
                viewerRef.onDisconnect().remove();
                
                await initClockSync();
                await create3DScene();
                
                getCachedElement('ui-overlay').classList.add('hidden');
                getCachedElement('vr-controls').style.display = 'flex';
                getCachedElement('room-info').style.display = 'block';
                getCachedElement('sync-status').style.display = 'block';
                
                updateRoomInfoDisplay();
                listenVideoState();
                listenSyncState(); // Listen for sync events
                
                if (isRoomOwner) {
                    startOwnerTasks();
                } else {
                    listenKeyframes();
                }
                
                // Start all periodic tasks
                startPeriodicTasks();
                
            } catch (error) {
                console.error('‚ùå Odaya katƒ±lma hatasƒ±:', error);
                alert('Odaya katƒ±lƒ±namadƒ±: ' + error.message);
            }
        }
        
        function leaveRoom() {
            if (currentRoomId && currentUser) {
                db.ref('rooms/' + currentRoomId + '/activeViewers/' + currentUser.uid).remove();
            }
            
            // Clear sync state
            clearSyncState();
            
            // Full cleanup
            fullCleanup();
            
            // Clean up video element properly (Memory Leak Prevention)
            if (videoElement) {
                videoElement.pause();
                videoElement.removeAttribute('src');
                videoElement.load(); // Force browser to release resources
                videoElement.remove();
                videoElement = null;
            }
            
            // Remove scene elements
            const scene = document.querySelector('a-scene');
            const videoScreen = document.getElementById('video-screen');
            const vrPanel = document.getElementById('vr-panel');
            
            if (videoScreen) videoScreen.remove();
            if (vrPanel) vrPanel.remove();
            
            getCachedElement('ui-overlay').classList.remove('hidden');
            getCachedElement('vr-controls').style.display = 'none';
            getCachedElement('room-info').style.display = 'none';
            getCachedElement('sync-status').style.display = 'none';
            
            currentRoomId = null;
            currentRoomData = null;
            isRoomOwner = false;
            lastDriftValue = null;
        }
        
        async function showRoomList() {
            try {
                // Ensure user is authenticated
                if (!auth.currentUser) {
                    await auth.signInAnonymously();
                }
                
                const roomsSnapshot = await db.ref('rooms').limitToLast(20).once('value');
                const roomList = getCachedElement('room-list');
                roomList.innerHTML = '';
                
                const rooms = [];
                const roomsToDelete = [];
                
                roomsSnapshot.forEach(child => {
                    const roomData = child.val();
                    const viewerCount = roomData.activeViewers ? Object.keys(roomData.activeViewers).length : 0;
                    
                    if (viewerCount === 0) {
                        roomsToDelete.push(child.key);
                    } else {
                        rooms.push({ id: child.key, data: roomData, viewers: viewerCount });
                    }
                });
                
                // Cleanup empty rooms
                roomsToDelete.forEach(roomId => {
                    db.ref('rooms/' + roomId).remove();
                });
                
                if (rooms.length === 0) {
                    roomList.innerHTML = '<p style="text-align: center; opacity: 0.7;">Aktif oda bulunamadƒ±</p>';
                } else {
                    rooms.forEach(room => {
                        const roomDiv = document.createElement('div');
                        roomDiv.className = 'room-item';
                        roomDiv.innerHTML = `
                            <div class="room-name">${room.data.name}</div>
                            <div class="room-details">üë• ${room.viewers} izleyici</div>
                        `;
                        roomDiv.onclick = () => joinRoom(room.id);
                        roomList.appendChild(roomDiv);
                    });
                }
                
                getCachedElement('create-room-section').classList.add('hidden');
                getCachedElement('room-list-section').classList.remove('hidden');
                
            } catch (error) {
                console.error('‚ùå Oda listesi hatasƒ±:', error);
                alert('Odalar y√ºklenirken hata olu≈ütu: ' + error.message + '\n\nL√ºtfen Firebase Rules ayarlarƒ±nƒ±zƒ± kontrol edin.');
            }
        }
        
        function showCreateRoom() {
            getCachedElement('room-list-section').classList.add('hidden');
            getCachedElement('create-room-section').classList.remove('hidden');
        }
        
        // ==================== 3D SCENE ====================
        async function create3DScene() {
            const scene = document.querySelector('a-scene');
            const assets = document.querySelector('a-assets');
            
            // Video element
            videoElement = document.createElement('video');
            videoElement.setAttribute('id', 'video-source');
            videoElement.setAttribute('crossorigin', 'anonymous');
            videoElement.setAttribute('playsinline', '');
            videoElement.setAttribute('webkit-playsinline', '');
            videoElement.setAttribute('preload', 'auto');
            videoElement.src = currentRoomData.videoUrl;
            
            // Critical: Wait for video to be ready before any operations
            videoElement.addEventListener('loadedmetadata', () => {
                debugLog('üìπ Video metadata loaded, duration:', videoElement.duration);
            });
            
            videoElement.addEventListener('canplay', () => {
                debugLog('üìπ Video can play');
                
                // If owner and room state says playing, start video
                if (isRoomOwner && currentRoomData.videoState && currentRoomData.videoState.isPlaying) {
                    videoElement.currentTime = currentRoomData.videoState.currentTime;
                    videoElement.play().catch(() => {});
                }
            });
            
            // Owner: Sync any manual video changes back to Firebase
            if (isRoomOwner) {
                videoElement.addEventListener('play', () => {
                    // ‚úÖ Ignore if in sync mode
                    if (syncState) return;
                    
                    if (currentRoomData.videoState && !currentRoomData.videoState.isPlaying) {
                        // User manually played - sync to Firebase
                        syncVideoState();
                    }
                });
                
                videoElement.addEventListener('pause', () => {
                    // ‚úÖ Ignore if in sync mode
                    if (syncState) return;
                    
                    if (currentRoomData.videoState && currentRoomData.videoState.isPlaying) {
                        // User manually paused - sync to Firebase
                        syncVideoState();
                    }
                });
                
                videoElement.addEventListener('seeked', () => {
                    // ‚úÖ Ignore if in sync mode
                    if (syncState) return;
                    
                    // User manually seeked - sync to Firebase
                    syncVideoState();
                });
            }
            
            assets.appendChild(videoElement);
            
            // Optimized environment (minimal or none)
            if (currentRoomData.environment === 'minimal') {
                const sky = document.createElement('a-sky');
                sky.setAttribute('color', '#000');
                scene.appendChild(sky);
            }
            
            // Screen sizes
            const screenSizes = {
                medium: { width: 8, height: 4.5 },
                large: { width: 10, height: 4.76 },
                imax: { width: 7, height: 10 }
            };
            
            const size = screenSizes[currentRoomData.screenSize] || screenSizes.medium;
            
            // Video screen
            const videoScreen = document.createElement('a-plane');
            videoScreen.setAttribute('id', 'video-screen');
            videoScreen.setAttribute('position', '0 2 -5');
            videoScreen.setAttribute('width', size.width);
            videoScreen.setAttribute('height', size.height);
            videoScreen.setAttribute('material', `src: #video-source; shader: flat`);
            scene.appendChild(videoScreen);
            
            // VR control panel (simplified)
            if (isRoomOwner) {
                const panel = document.createElement('a-entity');
                panel.setAttribute('id', 'vr-panel');
                panel.setAttribute('position', '0 1 -2');
                
                const buttons = [
                    { text: '‚ñ∂Ô∏è', position: '-0.6 0 0', event: 'play' },
                    { text: '‚è∏Ô∏è', position: '-0.2 0 0', event: 'pause' },
                    { text: '‚è™', position: '0.2 0 0', event: 'rewind' },
                    { text: '‚è©', position: '0.6 0 0', event: 'forward' }
                ];
                
                buttons.forEach(btn => {
                    const button = document.createElement('a-text');
                    button.setAttribute('value', btn.text);
                    button.setAttribute('position', btn.position);
                    button.setAttribute('align', 'center');
                    button.setAttribute('color', '#4ade80');
                    button.setAttribute('width', '4');
                    button.setAttribute('class', 'clickable');
                    button.addEventListener('click', () => handleVRButton(btn.event));
                    panel.appendChild(button);
                });
                
                scene.appendChild(panel);
            }
        }
        
        function handleVRButton(action) {
            switch(action) {
                case 'play': playVideo(); break;
                case 'pause': pauseVideo(); break;
                case 'rewind': seekBackward(); break;
                case 'forward': seekForward(); break;
            }
        }
        
        // ==================== VIDEO CONTROLS ====================
        function playVideo() {
            if (!videoElement) return;
            
            // Check if in sync mode
            if (syncState && syncState.isBuffering) {
                // In sync mode, only owner can trigger countdown
                if (!isRoomOwner) return;
                
                // Start countdown process
                startSyncCountdown();
                return;
            }
            
            // Normal play (owner only in non-sync mode)
            if (!isRoomOwner) return;
            
            // FIRST: Play the actual video element for room owner
            videoElement.play().then(() => {
                const serverTime = getServerTime();
                
                // THEN: Update Firebase
                db.ref('rooms/' + currentRoomId + '/videoState').update({
                    isPlaying: true,
                    currentTime: videoElement.currentTime,
                    startTimestamp: serverTime,
                    lastUpdate: firebase.database.ServerValue.TIMESTAMP
                });
            }).catch(error => {
                console.warn('Play error:', error);
                // Retry after short delay
                setTimeout(() => {
                    videoElement.play().catch(() => {});
                }, 500);
            });
        }
        
        function pauseVideo() {
            if (!isRoomOwner || !videoElement) return;
            
            // FIRST: Pause the actual video element for room owner
            videoElement.pause();
            
            // THEN: Update Firebase
            db.ref('rooms/' + currentRoomId + '/videoState').update({
                isPlaying: false,
                currentTime: videoElement.currentTime,
                lastUpdate: firebase.database.ServerValue.TIMESTAMP
            });
        }
        
        function seekBackward() {
            if (!isRoomOwner || !videoElement) return;
            videoElement.currentTime = Math.max(0, videoElement.currentTime - 10);
            syncVideoState();
        }
        
        function seekForward() {
            if (!isRoomOwner || !videoElement) return;
            videoElement.currentTime = Math.min(videoElement.duration, videoElement.currentTime + 10);
            syncVideoState();
        }
        
        // ==================== SYNC MECHANISM ====================
        
        function initiateSync() {
            if (!currentRoomId || !videoElement) return;
            
            debugLog('üîÑ Sync initiated by user');
            
            // Disable sync button
            const syncBtn = getCachedElement('btn-sync');
            if (syncBtn) syncBtn.disabled = true;
            
            // Collect all viewer positions
            db.ref('rooms/' + currentRoomId + '/activeViewers').once('value')
                .then(snapshot => {
                    const viewers = snapshot.val();
                    if (!viewers) return;
                    
                    // Get current positions from all viewers
                    const positions = [];
                    
                    // Add current user's position
                    positions.push(videoElement.currentTime);
                    
                    // Request positions from other viewers
                    Object.keys(viewers).forEach(uid => {
                        if (uid !== currentUser.uid && viewers[uid].currentPosition !== undefined) {
                            positions.push(viewers[uid].currentPosition);
                        }
                    });
                    
                    // Find the most behind viewer
                    const minPosition = Math.min(...positions);
                    const targetPosition = Math.max(0, minPosition - 4); // 4 seconds back
                    
                    debugLog('üìç Positions:', positions, '‚Üí Target:', targetPosition);
                    
                    // Update sync state in Firebase
                    db.ref('rooms/' + currentRoomId + '/syncState').set({
                        isBuffering: true,
                        syncedSeekPosition: targetPosition,
                        syncedPlayTime: null,
                        initiatedBy: currentUser.uid,
                        initiatedAt: firebase.database.ServerValue.TIMESTAMP
                    });
                    
                    // Apply sync locally immediately
                    applySyncState({
                        isBuffering: true,
                        syncedSeekPosition: targetPosition,
                        syncedPlayTime: null
                    });
                })
                .catch(error => {
                    console.error('Sync error:', error);
                    // Re-enable button on error
                    if (syncBtn) syncBtn.disabled = false;
                });
        }
        
        function applySyncState(state) {
            if (!videoElement || !state) return;
            
            syncState = state;
            syncModeActive = true; // ‚úÖ Activate sync mode
            
            if (state.isBuffering) {
                // Buffering phase: Pause and seek everyone
                videoElement.pause();
                videoElement.currentTime = state.syncedSeekPosition;
                
                // Update UI
                updateSyncUI('üîÑ Senkronizasyon ba≈ülatƒ±ldƒ±...');
                setTimeout(() => {
                    updateSyncUI(`‚è∏Ô∏è Video ${state.syncedSeekPosition.toFixed(1)}s'de duraklatƒ±ldƒ±`);
                }, 500);
                setTimeout(() => {
                    if (isRoomOwner) {
                        updateSyncUI('‚è≥ Hazƒ±r olduƒüunuzda ‚ñ∂Ô∏è OYNAT butonuna basƒ±n');
                    } else {
                        updateSyncUI('‚è≥ Oda sahibinin oynatmasƒ±nƒ± bekliyoruz...');
                    }
                }, 1000);
                
                // Disable controls except play for owner
                updateControlsForSync(true);
                
                // Auto-timeout after 30 seconds (owner only)
                if (isRoomOwner) {
                    syncTimeoutId = setTimeout(() => {
                        debugLog('‚è∞ Sync timeout - auto starting countdown');
                        startSyncCountdown();
                    }, 30000);
                }
                
            } else if (state.syncedPlayTime) {
                // Countdown phase
                startSyncCountdownFromState(state);
            }
        }
        
        function startSyncCountdown() {
            if (!isRoomOwner || !syncState) return;
            
            // Clear timeout if exists
            if (syncTimeoutId) {
                clearTimeout(syncTimeoutId);
                syncTimeoutId = null;
            }
            
            const playTime = Date.now() + 5000; // 5 seconds from now
            
            // Update Firebase
            db.ref('rooms/' + currentRoomId + '/syncState').update({
                isBuffering: false,
                syncedPlayTime: playTime
            });
        }
        
        function startSyncCountdownFromState(state) {
            if (!state.syncedPlayTime) return;
            
            const playTime = state.syncedPlayTime;
            const now = Date.now();
            
            if (playTime <= now) {
                // Time already passed, play immediately
                setTimeout(() => {
                    executeSync(state);
                }, 100); // Small delay to ensure everything is ready
                return;
            }
            
            // Show countdown
            const countdownElement = getCachedElement('sync-countdown');
            if (countdownElement) {
                countdownElement.style.display = 'block';
            }
            
            // Clear existing countdown
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            
            // Start countdown
            countdownInterval = setInterval(() => {
                const remaining = playTime - Date.now();
                
                if (remaining <= 0) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    
                    // Execute sync with small delay
                    setTimeout(() => {
                        executeSync(state);
                    }, 100);
                } else {
                    const seconds = Math.ceil(remaining / 1000);
                    if (countdownElement) {
                        countdownElement.textContent = `‚ñ∂Ô∏è ${seconds} saniye sonra ba≈ülƒ±yor...`;
                    }
                    updateSyncUI(`‚è±Ô∏è ${seconds} saniye sonra oynatƒ±lacak...`);
                }
            }, 100);
        }
        
        function executeSync(state) {
            if (!videoElement || !state) return;
            
            debugLog('üé¨ Executing sync at:', Date.now());
            
            // CRITICAL: Keep sync state active during execution
            // Don't clear it yet!
            
            // Seek and play
            videoElement.currentTime = state.syncedSeekPosition;
            videoElement.playbackRate = 1.0;
            
            videoElement.play().then(() => {
                debugLog('‚úÖ Sync play successful');
                
                // CRITICAL: Deactivate sync mode BEFORE Firebase update
                // so the update doesn't get ignored by listenVideoState
                syncModeActive = false;
                
                // Update Firebase (owner only)
                if (isRoomOwner) {
                    const serverTime = getServerTime();
                    db.ref('rooms/' + currentRoomId + '/videoState').update({
                        isPlaying: true,
                        currentTime: state.syncedSeekPosition,
                        startTimestamp: serverTime,
                        lastUpdate: firebase.database.ServerValue.TIMESTAMP
                    }).then(() => {
                        // THEN clear sync state after Firebase update completes
                        setTimeout(() => {
                            clearSyncState();
                        }, 500); // 500ms delay to ensure all systems updated
                    });
                } else {
                    // Participants: wait a bit then clear
                    setTimeout(() => {
                        clearSyncState();
                    }, 1000); // 1 second for participants
                }
            }).catch(error => {
                console.error('Sync play error:', error);
                // Clear sync state on error
                setTimeout(() => {
                    clearSyncState();
                }, 500);
            });
        }
        
        function clearSyncState() {
            syncState = null;
            syncModeActive = false; // ‚úÖ Deactivate sync mode
            
            // Clear countdown
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            
            // Clear timeout
            if (syncTimeoutId) {
                clearTimeout(syncTimeoutId);
                syncTimeoutId = null;
            }
            
            // Hide countdown UI
            const countdownElement = getCachedElement('sync-countdown');
            if (countdownElement) {
                countdownElement.style.display = 'none';
                countdownElement.textContent = '';
            }
            
            // Re-enable controls
            updateControlsForSync(false);
            
            // Clear sync state in Firebase (owner only)
            if (isRoomOwner && currentRoomId) {
                db.ref('rooms/' + currentRoomId + '/syncState').remove();
            }
            
            debugLog('üßπ Sync state cleared');
        }
        
        function updateSyncUI(message) {
            const statusText = getCachedElement('sync-text');
            if (statusText) {
                statusText.textContent = message;
                statusText.className = 'status-warning';
            }
        }
        
        function updateControlsForSync(inSync) {
            const playBtn = getCachedElement('btn-play');
            const pauseBtn = getCachedElement('btn-pause');
            const rewindBtn = getCachedElement('btn-rewind');
            const forwardBtn = getCachedElement('btn-forward');
            const syncBtn = getCachedElement('btn-sync');
            
            if (inSync) {
                // Disable all except play for owner
                if (pauseBtn) pauseBtn.disabled = true;
                if (rewindBtn) rewindBtn.disabled = true;
                if (forwardBtn) forwardBtn.disabled = true;
                if (syncBtn) syncBtn.disabled = true;
                
                if (playBtn) {
                    playBtn.disabled = !isRoomOwner;
                }
            } else {
                // Enable all for owner
                if (isRoomOwner) {
                    if (playBtn) playBtn.disabled = false;
                    if (pauseBtn) pauseBtn.disabled = false;
                    if (rewindBtn) rewindBtn.disabled = false;
                    if (forwardBtn) forwardBtn.disabled = false;
                }
                if (syncBtn) syncBtn.disabled = false;
            }
        }
        
        function listenSyncState() {
            const ref = db.ref('rooms/' + currentRoomId + '/syncState');
            trackListener(ref);
            
            ref.on('value', (snapshot) => {
                const state = snapshot.val();
                
                if (state) {
                    applySyncState(state);
                } else {
                    // Sync state cleared
                    if (syncState) {
                        clearSyncState();
                    }
                }
            });
        }
        
        // Update viewer position periodically for sync
        function updateViewerPosition() {
            if (!currentUser || !currentRoomId || !videoElement) return;
            
            try {
                db.ref('rooms/' + currentRoomId + '/activeViewers/' + currentUser.uid + '/currentPosition')
                    .set(videoElement.currentTime)
                    .catch(() => {});
            } catch (error) {
                console.warn('Position update error:', error);
            }
        }
        
        function syncVideoState() {
            if (!isRoomOwner || !videoElement) return;
            
            const serverTime = getServerTime();
            
            db.ref('rooms/' + currentRoomId + '/videoState').update({
                isPlaying: !videoElement.paused,
                currentTime: videoElement.currentTime,
                startTimestamp: serverTime,
                lastUpdate: firebase.database.ServerValue.TIMESTAMP
            });
        }
        
        // ==================== VIDEO SYNC (OPTIMIZED) ====================
        let lastVideoStateUpdate = 0;
        let previousVideoState = null;
        let syncModeActive = false; // ‚Üê YENƒ∞: Sync mode tracking
        
        function listenVideoState() {
            const ref = db.ref('rooms/' + currentRoomId + '/videoState');
            trackListener(ref);
            
            ref.on('value', (snapshot) => {
                const newState = snapshot.val();
                if (!newState) return;
                
                // ‚úÖ CRITICAL: Ignore updates during sync execution
                if (syncModeActive) {
                    debugLog('‚è∏Ô∏è Ignoring video state update - sync mode active');
                    return;
                }
                
                // Prevent infinite loop - check if state actually changed
                if (previousVideoState && 
                    previousVideoState.isPlaying === newState.isPlaying &&
                    Math.abs(previousVideoState.currentTime - newState.currentTime) < 0.1 &&
                    previousVideoState.startTimestamp === newState.startTimestamp) {
                    return; // No meaningful change, skip
                }
                
                previousVideoState = JSON.parse(JSON.stringify(newState)); // Deep copy
                currentRoomData.videoState = newState;
                
                if (!isRoomOwner) {
                    // Throttled sync check for participants
                    const now = Date.now();
                    if (now - lastVideoStateUpdate < SYNC_CHECK_INTERVAL) {
                        return;
                    }
                    lastVideoStateUpdate = now;
                    
                    syncVideo();
                }
                // Owner doesn't need syncVideo - they control the video directly
            });
        }
        
        function syncVideo() {
            if (!videoElement || !currentRoomData || !currentRoomData.videoState) return;
            
            // Don't sync if in sync mode
            if (syncState) return;
            
            const state = currentRoomData.videoState;
            const serverTime = getServerTime();
            
            let expectedTime = state.currentTime;
            if (state.isPlaying) {
                const elapsed = (serverTime - state.startTimestamp) / 1000;
                expectedTime = state.currentTime + elapsed;
            }
            
            const currentTime = videoElement.currentTime;
            const drift = Math.abs(currentTime - expectedTime) * 1000;
            
            debugLog('üéØ Sync - Expected:', expectedTime, 'Current:', currentTime, 'Drift:', drift);
            
            // OPTIMIZED SYNC STRATEGY with playbackRate
            if (drift < TIER1_THRESHOLD) {
                // Perfect sync - normal playback
                if (state.isPlaying && videoElement.paused) {
                    videoElement.play().catch(err => {
                        console.warn('Play failed:', err);
                        // Retry once
                        setTimeout(() => videoElement.play().catch(() => {}), 200);
                    });
                } else if (!state.isPlaying && !videoElement.paused) {
                    videoElement.pause();
                }
                videoElement.playbackRate = 1.0;
                
            } else if (drift < TIER2_THRESHOLD) {
                // Small drift - use playbackRate for smooth correction
                if (state.isPlaying) {
                    if (videoElement.paused) {
                        videoElement.play().catch(() => {});
                    }
                    
                    // Soft speed adjustment
                    const behind = currentTime < expectedTime;
                    videoElement.playbackRate = behind ? TIER2_LAGGING_SPEED : 0.95;
                } else {
                    videoElement.pause();
                    videoElement.playbackRate = 1.0;
                }
                
            } else if (drift < TIER3_THRESHOLD) {
                // Medium drift - more aggressive playbackRate
                if (state.isPlaying) {
                    if (videoElement.paused) {
                        videoElement.play().catch(() => {});
                    }
                    
                    const behind = currentTime < expectedTime;
                    videoElement.playbackRate = behind ? TIER3_LAGGING_SPEED : 0.90;
                } else {
                    videoElement.pause();
                    videoElement.playbackRate = 1.0;
                }
                
            } else {
                // Large drift - hard seek
                debugLog('‚ö†Ô∏è Large drift detected, seeking to:', expectedTime);
                videoElement.currentTime = expectedTime;
                
                if (state.isPlaying && videoElement.paused) {
                    videoElement.play().catch(() => {});
                } else if (!state.isPlaying && !videoElement.paused) {
                    videoElement.pause();
                }
                videoElement.playbackRate = 1.0;
            }
            
            updateSyncStatus(drift);
        }
        
        function sendKeyframe() {
            if (!videoElement || !isRoomOwner) return;
            
            try {
                const ref = db.ref('rooms/' + currentRoomId + '/keyframes').push({
                    time: videoElement.currentTime,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });
                
                // Auto-delete after 30 seconds
                trackTimeout(setTimeout(() => ref.remove().catch(() => {}), 30000));
            } catch (error) {
                console.warn('Keyframe send error:', error);
            }
        }
        
        function listenKeyframes() {
            const ref = db.ref('rooms/' + currentRoomId + '/keyframes').limitToLast(1);
            trackListener(ref);
            
            ref.on('child_added', (snapshot) => {
                const keyframe = snapshot.val();
                if (!videoElement) return;
                
                const drift = Math.abs(videoElement.currentTime - keyframe.time) * 1000;
                
                if (drift > TIER3_THRESHOLD) {
                    videoElement.currentTime = keyframe.time;
                    debugLog('üîë Keyframe sync:', keyframe.time);
                }
            });
        }
        
        function trackDrift() {
            if (!videoElement || !currentRoomData || !currentRoomData.videoState) return;
            
            try {
                const state = currentRoomData.videoState;
                const serverTime = getServerTime();
                const expectedTime = state.isPlaying 
                    ? state.currentTime + (serverTime - state.startTimestamp) / 1000
                    : state.currentTime;
                
                const drift = (videoElement.currentTime - expectedTime) * 1000;
                
                // Only update if drift changed significantly
                if (lastDriftValue === null || Math.abs(drift - lastDriftValue) > 1000) {
                    if (shouldUpdateFirebase()) {
                        queueFirebaseUpdate(
                            'activeViewers/' + currentUser.uid + '/currentDrift',
                            drift
                        );
                        lastDriftValue = drift;
                    }
                }
            } catch (error) {
                console.warn('Drift tracking error:', error);
            }
        }
        
        function updatePresence() {
            if (!currentUser || !currentRoomId) return;
            
            try {
                queueFirebaseUpdate(
                    'activeViewers/' + currentUser.uid + '/lastSeen',
                    firebase.database.ServerValue.TIMESTAMP
                );
            } catch (error) {
                console.warn('Presence update error:', error);
            }
        }
        
        function checkOwnerPresence() {
            if (!isRoomOwner && currentRoomData && currentUser) {
                db.ref('rooms/' + currentRoomId + '/activeViewers/' + currentRoomData.owner).once('value')
                    .then(snapshot => {
                        const ownerData = snapshot.val();
                        if (!ownerData || (Date.now() - ownerData.lastSeen > OWNER_PRESENCE_TIMEOUT)) {
                            // Transfer ownership
                            db.ref('rooms/' + currentRoomId + '/activeViewers').once('value')
                                .then(viewersSnapshot => {
                                    const viewers = viewersSnapshot.val();
                                    if (viewers) {
                                        const newOwner = Object.keys(viewers)[0];
                                        if (newOwner === currentUser.uid) {
                                            db.ref('rooms/' + currentRoomId).update({ owner: newOwner });
                                            isRoomOwner = true;
                                            debugLog('üëë Ownership transferred to you');
                                        }
                                    }
                                });
                        }
                    })
                    .catch(() => {});
            }
        }
        
        // ==================== UI UPDATES (DEBOUNCED) ====================
        function updateRoomInfoDisplay() {
            if (!currentRoomData) return;
            getCachedElement('room-name-display').textContent = currentRoomData.name;
            updateViewerCount();
        }
        
        function updateViewerCount() {
            if (!currentRoomId || !shouldUpdateUI()) return;
            
            db.ref('rooms/' + currentRoomId + '/activeViewers').once('value')
                .then(snapshot => {
                    const count = snapshot.numChildren();
                    requestAnimationFrame(() => {
                        const viewerElement = getCachedElement('viewer-count');
                        if (viewerElement) {
                            viewerElement.textContent = `üë• ${count} izleyici`;
                        }
                    });
                })
                .catch(() => {});
        }
        
        function cleanupOldData() {
            if (!currentRoomId || !isRoomOwner) return;
            
            try {
                const cutoffTime = Date.now() - 60000;
                
                db.ref('rooms/' + currentRoomId + '/keyframes').once('value')
                    .then(snapshot => {
                        if (snapshot.exists()) {
                            snapshot.forEach(child => {
                                const data = child.val();
                                if (data.timestamp && data.timestamp < cutoffTime) {
                                    child.ref.remove().catch(() => {});
                                }
                            });
                        }
                    })
                    .catch(() => {});
                
                debugLog('üßπ Cleanup old data');
            } catch (error) {
                console.warn('Cleanup error:', error);
            }
        }
        
        function updateSyncStatus(drift) {
            if (!shouldUpdateUI()) return;
            
            requestAnimationFrame(() => {
                const statusText = getCachedElement('sync-text');
                if (!statusText) return;
                
                if (drift < TIER1_THRESHOLD) {
                    statusText.textContent = '‚úÖ Senkronize';
                    statusText.className = 'status-good';
                } else if (drift < TIER2_THRESHOLD) {
                    statusText.textContent = '‚ö†Ô∏è Hafif sapma';
                    statusText.className = 'status-warning';
                } else {
                    statusText.textContent = '‚ùå Senkronizasyon kaybƒ±';
                    statusText.className = 'status-error';
                }
            });
        }
        
        // ==================== PERIODIC TASKS ====================
        function startPeriodicTasks() {
            // Clock sync every 60 seconds
            trackInterval(setInterval(initClockSync, CLOCK_SYNC_INTERVAL));
            
            // Drift tracking every 5 seconds
            trackInterval(setInterval(trackDrift, DRIFT_UPDATE_INTERVAL));
            
            // Presence update every 30 seconds
            trackInterval(setInterval(updatePresence, PRESENCE_UPDATE_INTERVAL));
            
            // Viewer count UI update every 5 seconds
            trackInterval(setInterval(updateViewerCount, 5000));
            
            // Viewer position update every 3 seconds (for sync mechanism)
            trackInterval(setInterval(updateViewerPosition, 3000));
            
            // Owner presence check every 30 seconds (non-owners only)
            if (!isRoomOwner) {
                trackInterval(setInterval(checkOwnerPresence, 30000));
                
                // CRITICAL: Periodic sync check for participants (backup mechanism)
                trackInterval(setInterval(() => {
                    if (currentRoomData && currentRoomData.videoState && !syncState) {
                        syncVideo();
                    }
                }, 2000)); // Every 2 seconds as backup
            }
            
            debugLog('‚úÖ Periodic tasks started');
        }
        
        function startOwnerTasks() {
            // Keyframe sending every 10 seconds (owner only)
            trackInterval(setInterval(sendKeyframe, KEYFRAME_INTERVAL));
            
            // Cleanup old data every 10 seconds (owner only)
            trackInterval(setInterval(cleanupOldData, CLEANUP_INTERVAL));
            
            debugLog('üëë Owner tasks started');
        }
        
        // ==================== INIT ====================
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üé¨ VR Cinema ULTRA - Optimized v2.0 Ready!');
            
            // VR mode enter/exit handlers
            const scene = document.querySelector('a-scene');
            if (scene) {
                scene.addEventListener('enter-vr', () => {
                    const cursor = getCachedElement('vr-cursor');
                    if (cursor) {
                        cursor.setAttribute('visible', 'true');
                        debugLog('üëì VR mode: Raycaster enabled');
                    }
                });
                
                scene.addEventListener('exit-vr', () => {
                    const cursor = getCachedElement('vr-cursor');
                    if (cursor) {
                        cursor.setAttribute('visible', 'false');
                        debugLog('üëì VR mode exit: Raycaster disabled');
                    }
                });
            }
            
            // Keyboard shortcuts (owner only)
            document.addEventListener('keydown', (e) => {
                if (!currentRoomId || !isRoomOwner) return;
                
                switch(e.key) {
                    case ' ':
                        e.preventDefault();
                        if (videoElement && videoElement.paused) {
                            playVideo();
                        } else {
                            pauseVideo();
                        }
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        seekBackward();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        seekForward();
                        break;
                }
            });
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            fullCleanup();
        });
    </script>
</body>
</html>